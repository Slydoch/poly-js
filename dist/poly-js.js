/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nconst Vector2 = __webpack_require__(/*! ./src/vector2 */ \"./src/vector2.js\");\r\nconst Line = __webpack_require__(/*! ./src/line */ \"./src/line.js\");\r\nconst Polygon = __webpack_require__(/*! ./src/polygon */ \"./src/polygon.js\");\r\nconst Rect = __webpack_require__(/*! ./src/rect */ \"./src/rect.js\");\r\nconst Circle = __webpack_require__(/*! ./src/circle */ \"./src/circle.js\");\r\n\r\nmodule.exports = {\r\n\tVector2,\r\n\tLine,\r\n\tPolygon,\r\n\tRect,\r\n\tCircle\r\n};\r\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/polybooljs/index.js":
/*!******************************************!*\
  !*** ./node_modules/polybooljs/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc\n * @license MIT\n * @preserve Project Home: https://github.com/voidqk/polybooljs\n */\n\nvar BuildLog = __webpack_require__(/*! ./lib/build-log */ \"./node_modules/polybooljs/lib/build-log.js\");\nvar Epsilon = __webpack_require__(/*! ./lib/epsilon */ \"./node_modules/polybooljs/lib/epsilon.js\");\nvar Intersecter = __webpack_require__(/*! ./lib/intersecter */ \"./node_modules/polybooljs/lib/intersecter.js\");\nvar SegmentChainer = __webpack_require__(/*! ./lib/segment-chainer */ \"./node_modules/polybooljs/lib/segment-chainer.js\");\nvar SegmentSelector = __webpack_require__(/*! ./lib/segment-selector */ \"./node_modules/polybooljs/lib/segment-selector.js\");\nvar GeoJSON = __webpack_require__(/*! ./lib/geojson */ \"./node_modules/polybooljs/lib/geojson.js\");\n\nvar buildLog = false;\nvar epsilon = Epsilon();\n\nvar PolyBool;\nPolyBool = {\n\t// getter/setter for buildLog\n\tbuildLog: function(bl){\n\t\tif (bl === true)\n\t\t\tbuildLog = BuildLog();\n\t\telse if (bl === false)\n\t\t\tbuildLog = false;\n\t\treturn buildLog === false ? false : buildLog.list;\n\t},\n\t// getter/setter for epsilon\n\tepsilon: function(v){\n\t\treturn epsilon.epsilon(v);\n\t},\n\n\t// core API\n\tsegments: function(poly){\n\t\tvar i = Intersecter(true, epsilon, buildLog);\n\t\tpoly.regions.forEach(i.addRegion);\n\t\treturn {\n\t\t\tsegments: i.calculate(poly.inverted),\n\t\t\tinverted: poly.inverted\n\t\t};\n\t},\n\tcombine: function(segments1, segments2){\n\t\tvar i3 = Intersecter(false, epsilon, buildLog);\n\t\treturn {\n\t\t\tcombined: i3.calculate(\n\t\t\t\tsegments1.segments, segments1.inverted,\n\t\t\t\tsegments2.segments, segments2.inverted\n\t\t\t),\n\t\t\tinverted1: segments1.inverted,\n\t\t\tinverted2: segments2.inverted\n\t\t};\n\t},\n\tselectUnion: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.union(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 || combined.inverted2\n\t\t}\n\t},\n\tselectIntersect: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.intersect(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectDifference: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.difference(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && !combined.inverted2\n\t\t}\n\t},\n\tselectDifferenceRev: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.differenceRev(combined.combined, buildLog),\n\t\t\tinverted: !combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectXor: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.xor(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 !== combined.inverted2\n\t\t}\n\t},\n\tpolygon: function(segments){\n\t\treturn {\n\t\t\tregions: SegmentChainer(segments.segments, epsilon, buildLog),\n\t\t\tinverted: segments.inverted\n\t\t};\n\t},\n\n\t// GeoJSON converters\n\tpolygonFromGeoJSON: function(geojson){\n\t\treturn GeoJSON.toPolygon(PolyBool, geojson);\n\t},\n\tpolygonToGeoJSON: function(poly){\n\t\treturn GeoJSON.fromPolygon(PolyBool, epsilon, poly);\n\t},\n\n\t// helper functions for common operations\n\tunion: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectUnion);\n\t},\n\tintersect: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectIntersect);\n\t},\n\tdifference: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifference);\n\t},\n\tdifferenceRev: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifferenceRev);\n\t},\n\txor: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectXor);\n\t}\n};\n\nfunction operate(poly1, poly2, selector){\n\tvar seg1 = PolyBool.segments(poly1);\n\tvar seg2 = PolyBool.segments(poly2);\n\tvar comb = PolyBool.combine(seg1, seg2);\n\tvar seg3 = selector(comb);\n\treturn PolyBool.polygon(seg3);\n}\n\nif (typeof window === 'object')\n\twindow.PolyBool = PolyBool;\n\nmodule.exports = PolyBool;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/index.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/build-log.js":
/*!**************************************************!*\
  !*** ./node_modules/polybooljs/lib/build-log.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// used strictly for logging the processing of the algorithm... only useful if you intend on\n// looking under the covers (for pretty UI's or debugging)\n//\n\nfunction BuildLog(){\n\tvar my;\n\tvar nextSegmentId = 0;\n\tvar curVert = false;\n\n\tfunction push(type, data){\n\t\tmy.list.push({\n\t\t\ttype: type,\n\t\t\tdata: data ? JSON.parse(JSON.stringify(data)) : void 0\n\t\t});\n\t\treturn my;\n\t}\n\n\tmy = {\n\t\tlist: [],\n\t\tsegmentId: function(){\n\t\t\treturn nextSegmentId++;\n\t\t},\n\t\tcheckIntersection: function(seg1, seg2){\n\t\t\treturn push('check', { seg1: seg1, seg2: seg2 });\n\t\t},\n\t\tsegmentChop: function(seg, end){\n\t\t\tpush('div_seg', { seg: seg, pt: end });\n\t\t\treturn push('chop', { seg: seg, pt: end });\n\t\t},\n\t\tstatusRemove: function(seg){\n\t\t\treturn push('pop_seg', { seg: seg });\n\t\t},\n\t\tsegmentUpdate: function(seg){\n\t\t\treturn push('seg_update', { seg: seg });\n\t\t},\n\t\tsegmentNew: function(seg, primary){\n\t\t\treturn push('new_seg', { seg: seg, primary: primary });\n\t\t},\n\t\tsegmentRemove: function(seg){\n\t\t\treturn push('rem_seg', { seg: seg });\n\t\t},\n\t\ttempStatus: function(seg, above, below){\n\t\t\treturn push('temp_status', { seg: seg, above: above, below: below });\n\t\t},\n\t\trewind: function(seg){\n\t\t\treturn push('rewind', { seg: seg });\n\t\t},\n\t\tstatus: function(seg, above, below){\n\t\t\treturn push('status', { seg: seg, above: above, below: below });\n\t\t},\n\t\tvert: function(x){\n\t\t\tif (x === curVert)\n\t\t\t\treturn my;\n\t\t\tcurVert = x;\n\t\t\treturn push('vert', { x: x });\n\t\t},\n\t\tlog: function(data){\n\t\t\tif (typeof data !== 'string')\n\t\t\t\tdata = JSON.stringify(data, false, '  ');\n\t\t\treturn push('log', { txt: data });\n\t\t},\n\t\treset: function(){\n\t\t\treturn push('reset');\n\t\t},\n\t\tselected: function(segs){\n\t\t\treturn push('selected', { segs: segs });\n\t\t},\n\t\tchainStart: function(seg){\n\t\t\treturn push('chain_start', { seg: seg });\n\t\t},\n\t\tchainRemoveHead: function(index, pt){\n\t\t\treturn push('chain_rem_head', { index: index, pt: pt });\n\t\t},\n\t\tchainRemoveTail: function(index, pt){\n\t\t\treturn push('chain_rem_tail', { index: index, pt: pt });\n\t\t},\n\t\tchainNew: function(pt1, pt2){\n\t\t\treturn push('chain_new', { pt1: pt1, pt2: pt2 });\n\t\t},\n\t\tchainMatch: function(index){\n\t\t\treturn push('chain_match', { index: index });\n\t\t},\n\t\tchainClose: function(index){\n\t\t\treturn push('chain_close', { index: index });\n\t\t},\n\t\tchainAddHead: function(index, pt){\n\t\t\treturn push('chain_add_head', { index: index, pt: pt });\n\t\t},\n\t\tchainAddTail: function(index, pt){\n\t\t\treturn push('chain_add_tail', { index: index, pt: pt, });\n\t\t},\n\t\tchainConnect: function(index1, index2){\n\t\t\treturn push('chain_con', { index1: index1, index2: index2 });\n\t\t},\n\t\tchainReverse: function(index){\n\t\t\treturn push('chain_rev', { index: index });\n\t\t},\n\t\tchainJoin: function(index1, index2){\n\t\t\treturn push('chain_join', { index1: index1, index2: index2 });\n\t\t},\n\t\tdone: function(){\n\t\t\treturn push('done');\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = BuildLog;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/build-log.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/epsilon.js":
/*!************************************************!*\
  !*** ./node_modules/polybooljs/lib/epsilon.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\n\nfunction Epsilon(eps){\n\tif (typeof eps !== 'number')\n\t\teps = 0.0000000001; // sane default? sure why not\n\tvar my = {\n\t\tepsilon: function(v){\n\t\t\tif (typeof v === 'number')\n\t\t\t\teps = v;\n\t\t\treturn eps;\n\t\t},\n\t\tpointAboveOrOnLine: function(pt, left, right){\n\t\t\tvar Ax = left[0];\n\t\t\tvar Ay = left[1];\n\t\t\tvar Bx = right[0];\n\t\t\tvar By = right[1];\n\t\t\tvar Cx = pt[0];\n\t\t\tvar Cy = pt[1];\n\t\t\treturn (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n\t\t},\n\t\tpointBetween: function(p, left, right){\n\t\t\t// p must be collinear with left->right\n\t\t\t// returns false if p == left, p == right, or left == right\n\t\t\tvar d_py_ly = p[1] - left[1];\n\t\t\tvar d_rx_lx = right[0] - left[0];\n\t\t\tvar d_px_lx = p[0] - left[0];\n\t\t\tvar d_ry_ly = right[1] - left[1];\n\n\t\t\tvar dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;\n\t\t\t// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n\t\t\t// if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\t\t\tif (dot < eps)\n\t\t\t\treturn false;\n\n\t\t\tvar sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;\n\t\t\t// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n\t\t\t// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\t\t\tif (dot - sqlen > -eps)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t},\n\t\tpointsSameX: function(p1, p2){\n\t\t\treturn Math.abs(p1[0] - p2[0]) < eps;\n\t\t},\n\t\tpointsSameY: function(p1, p2){\n\t\t\treturn Math.abs(p1[1] - p2[1]) < eps;\n\t\t},\n\t\tpointsSame: function(p1, p2){\n\t\t\treturn my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n\t\t},\n\t\tpointsCompare: function(p1, p2){\n\t\t\t// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n\t\t\tif (my.pointsSameX(p1, p2))\n\t\t\t\treturn my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);\n\t\t\treturn p1[0] < p2[0] ? -1 : 1;\n\t\t},\n\t\tpointsCollinear: function(pt1, pt2, pt3){\n\t\t\t// does pt1->pt2->pt3 make a straight line?\n\t\t\t// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n\t\t\t// if slopes are equal, then they must be collinear, because they share pt2\n\t\t\tvar dx1 = pt1[0] - pt2[0];\n\t\t\tvar dy1 = pt1[1] - pt2[1];\n\t\t\tvar dx2 = pt2[0] - pt3[0];\n\t\t\tvar dy2 = pt2[1] - pt3[1];\n\t\t\treturn Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n\t\t},\n\t\tlinesIntersect: function(a0, a1, b0, b1){\n\t\t\t// returns false if the lines are coincident (e.g., parallel or on top of each other)\n\t\t\t//\n\t\t\t// returns an object if the lines intersect:\n\t\t\t//   {\n\t\t\t//     pt: [x, y],    where the intersection point is at\n\t\t\t//     alongA: where intersection point is along A,\n\t\t\t//     alongB: where intersection point is along B\n\t\t\t//   }\n\t\t\t//\n\t\t\t//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n\t\t\t//\n\t\t\t//  with the following meaning:\n\t\t\t//\n\t\t\t//    -2   intersection point is before segment's first point\n\t\t\t//    -1   intersection point is directly on segment's first point\n\t\t\t//     0   intersection point is between segment's first and second points (exclusive)\n\t\t\t//     1   intersection point is directly on segment's second point\n\t\t\t//     2   intersection point is after segment's second point\n\t\t\tvar adx = a1[0] - a0[0];\n\t\t\tvar ady = a1[1] - a0[1];\n\t\t\tvar bdx = b1[0] - b0[0];\n\t\t\tvar bdy = b1[1] - b0[1];\n\n\t\t\tvar axb = adx * bdy - ady * bdx;\n\t\t\tif (Math.abs(axb) < eps)\n\t\t\t\treturn false; // lines are coincident\n\n\t\t\tvar dx = a0[0] - b0[0];\n\t\t\tvar dy = a0[1] - b0[1];\n\n\t\t\tvar A = (bdx * dy - bdy * dx) / axb;\n\t\t\tvar B = (adx * dy - ady * dx) / axb;\n\n\t\t\tvar ret = {\n\t\t\t\talongA: 0,\n\t\t\t\talongB: 0,\n\t\t\t\tpt: [\n\t\t\t\t\ta0[0] + A * adx,\n\t\t\t\t\ta0[1] + A * ady\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// categorize where intersection point is along A and B\n\n\t\t\tif (A <= -eps)\n\t\t\t\tret.alongA = -2;\n\t\t\telse if (A < eps)\n\t\t\t\tret.alongA = -1;\n\t\t\telse if (A - 1 <= -eps)\n\t\t\t\tret.alongA = 0;\n\t\t\telse if (A - 1 < eps)\n\t\t\t\tret.alongA = 1;\n\t\t\telse\n\t\t\t\tret.alongA = 2;\n\n\t\t\tif (B <= -eps)\n\t\t\t\tret.alongB = -2;\n\t\t\telse if (B < eps)\n\t\t\t\tret.alongB = -1;\n\t\t\telse if (B - 1 <= -eps)\n\t\t\t\tret.alongB = 0;\n\t\t\telse if (B - 1 < eps)\n\t\t\t\tret.alongB = 1;\n\t\t\telse\n\t\t\t\tret.alongB = 2;\n\n\t\t\treturn ret;\n\t\t},\n\t\tpointInsideRegion: function(pt, region){\n\t\t\tvar x = pt[0];\n\t\t\tvar y = pt[1];\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar inside = false;\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\n\t\t\t\t// if y is between curr_y and last_y, and\n\t\t\t\t// x is to the right of the boundary created by the line\n\t\t\t\tif ((curr_y - y > eps) != (last_y - y > eps) &&\n\t\t\t\t\t(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)\n\t\t\t\t\tinside = !inside\n\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\treturn inside;\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = Epsilon;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/epsilon.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/geojson.js":
/*!************************************************!*\
  !*** ./node_modules/polybooljs/lib/geojson.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n\t// convert a GeoJSON object to a PolyBool polygon\n\ttoPolygon: function(PolyBool, geojson){\n\n\t\t// converts list of LineString's to segments\n\t\tfunction GeoPoly(coords){\n\t\t\t// check for empty coords\n\t\t\tif (coords.length <= 0)\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\n\n\t\t\t// convert LineString to segments\n\t\t\tfunction LineString(ls){\n\t\t\t\t// remove tail which should be the same as head\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\n\t\t\t}\n\n\t\t\t// the first LineString is considered the outside\n\t\t\tvar out = LineString(coords[0]);\n\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\n\t\t\t// current result\n\t\t\tfor (var i = 1; i < coords.length; i++)\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n\t\t\treturn out;\n\t\t}\n\n\t\tif (geojson.type === 'Polygon'){\n\t\t\t// single polygon, so just convert it and we're done\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\n\t\t}\n\t\telse if (geojson.type === 'MultiPolygon'){\n\t\t\t// multiple polygons, so union all the polygons together\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\t\t\treturn PolyBool.polygon(out);\n\t\t}\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n\t},\n\n\t// convert a PolyBool polygon to a GeoJSON object\n\tfromPolygon: function(PolyBool, eps, poly){\n\t\t// make sure out polygon is clean\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\n\n\t\t// test if r1 is inside r2\n\t\tfunction regionInsideRegion(r1, r2){\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n\t\t\t// edge of the first line, which cannot be on an edge\n\t\t\treturn eps.pointInsideRegion([\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\n\t\t\t], r2);\n\t\t}\n\n\t\t// calculate inside heirarchy\n\t\t//\n\t\t//  _____________________   _______    roots -> A       -> F\n\t\t// |          A          | |   F   |            |          |\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\n\t\t// | |   B   | |   C   | | | |   | |            |   |\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\n\t\t// | | | D | | | | E | | | | | G | |            |\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\n\t\t// | |_______| |_______| | | |___| |                |\n\t\t// |_____________________| |_______|                +-- E\n\n\t\tfunction newNode(region){\n\t\t\treturn {\n\t\t\t\tregion: region,\n\t\t\t\tchildren: []\n\t\t\t};\n\t\t}\n\n\t\tvar roots = newNode(null);\n\n\t\tfunction addChild(root, region){\n\t\t\t// first check if we're inside any children\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(region, child.region)){\n\t\t\t\t\t// we are, so insert inside them instead\n\t\t\t\t\taddChild(child, region);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not inside any children, so check to see if any children are inside us\n\t\t\tvar node = newNode(region);\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(child.region, region)){\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\n\t\t\t\t\tnode.children.push(child);\n\t\t\t\t\troot.children.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we can add ourselves\n\t\t\troot.children.push(node);\n\t\t}\n\n\t\t// add all regions to the root\n\t\tfor (var i = 0; i < poly.regions.length; i++){\n\t\t\tvar region = poly.regions[i];\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\n\t\t\t\tcontinue;\n\t\t\taddChild(roots, region);\n\t\t}\n\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\n\t\t// children's children's children are interior, etc\n\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\t\tfunction forceWinding(region, clockwise){\n\t\t\t// first, see if we're clockwise or counter-clockwise\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\n\t\t\tvar winding = 0;\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar copy = [];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\n\t\t\tvar isclockwise = winding < 0;\n\t\t\tif (isclockwise !== clockwise)\n\t\t\t\tcopy.reverse();\n\t\t\t// while we're here, the last point must be the first point...\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\n\t\t\treturn copy;\n\t\t}\n\n\t\tvar geopolys = [];\n\n\t\tfunction addExterior(node){\n\t\t\tvar poly = [forceWinding(node.region, false)];\n\t\t\tgeopolys.push(poly);\n\t\t\t// children of exteriors are interior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\tpoly.push(getInterior(node.children[i]));\n\t\t}\n\n\t\tfunction getInterior(node){\n\t\t\t// children of interiors are exterior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\taddExterior(node.children[i]);\n\t\t\t// return the clockwise interior\n\t\t\treturn forceWinding(node.region, true);\n\t\t}\n\n\t\t// root nodes are exterior\n\t\tfor (var i = 0; i < roots.children.length; i++)\n\t\t\taddExterior(roots.children[i]);\n\n\t\t// lastly, construct the approrpriate GeoJSON object\n\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: [] };\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\n\t\t\ttype: 'MultiPolygon',\n\t\t\tcoordinates: geopolys\n\t\t};\n\t}\n};\n\nmodule.exports = GeoJSON;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/geojson.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/intersecter.js":
/*!****************************************************!*\
  !*** ./node_modules/polybooljs/lib/intersecter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = __webpack_require__(/*! ./linked-list */ \"./node_modules/polybooljs/lib/linked-list.js\");\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/intersecter.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/linked-list.js":
/*!****************************************************!*\
  !*** ./node_modules/polybooljs/lib/linked-list.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// simple linked list implementation that allows you to traverse down nodes and save positions\n//\n\nvar LinkedList = {\n\tcreate: function(){\n\t\tvar my = {\n\t\t\troot: { root: true, next: null },\n\t\t\texists: function(node){\n\t\t\t\tif (node === null || node === my.root)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tisEmpty: function(){\n\t\t\t\treturn my.root.next === null;\n\t\t\t},\n\t\t\tgetHead: function(){\n\t\t\t\treturn my.root.next;\n\t\t\t},\n\t\t\tinsertBefore: function(node, check){\n\t\t\t\tvar last = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here)){\n\t\t\t\t\t\tnode.prev = here.prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\there.prev.next = node;\n\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlast = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\tlast.next = node;\n\t\t\t\tnode.prev = last;\n\t\t\t\tnode.next = null;\n\t\t\t},\n\t\t\tfindTransition: function(check){\n\t\t\t\tvar prev = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbefore: prev === my.root ? null : prev,\n\t\t\t\t\tafter: here,\n\t\t\t\t\tinsert: function(node){\n\t\t\t\t\t\tnode.prev = prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\tprev.next = node;\n\t\t\t\t\t\tif (here !== null)\n\t\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn my;\n\t},\n\tnode: function(data){\n\t\tdata.prev = null;\n\t\tdata.next = null;\n\t\tdata.remove = function(){\n\t\t\tdata.prev.next = data.next;\n\t\t\tif (data.next)\n\t\t\t\tdata.next.prev = data.prev;\n\t\t\tdata.prev = null;\n\t\t\tdata.next = null;\n\t\t};\n\t\treturn data;\n\t}\n};\n\nmodule.exports = LinkedList;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/linked-list.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/segment-chainer.js":
/*!********************************************************!*\
  !*** ./node_modules/polybooljs/lib/segment-chainer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\n\nfunction SegmentChainer(segments, eps, buildLog){\n\tvar chains = [];\n\tvar regions = [];\n\n\tsegments.forEach(function(seg){\n\t\tvar pt1 = seg.start;\n\t\tvar pt2 = seg.end;\n\t\tif (eps.pointsSame(pt1, pt2)){\n\t\t\tconsole.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t'probably too small or too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainStart(seg);\n\n\t\t// search for two chains that this segment matches\n\t\tvar first_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar second_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar next_match = first_match;\n\t\tfunction setMatch(index, matches_head, matches_pt1){\n\t\t\t// return true if we've matched twice\n\t\t\tnext_match.index = index;\n\t\t\tnext_match.matches_head = matches_head;\n\t\t\tnext_match.matches_pt1 = matches_pt1;\n\t\t\tif (next_match === first_match){\n\t\t\t\tnext_match = second_match;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnext_match = null;\n\t\t\treturn true; // we've matched twice, we're done here\n\t\t}\n\t\tfor (var i = 0; i < chains.length; i++){\n\t\t\tvar chain = chains[i];\n\t\t\tvar head  = chain[0];\n\t\t\tvar head2 = chain[1];\n\t\t\tvar tail  = chain[chain.length - 1];\n\t\t\tvar tail2 = chain[chain.length - 2];\n\t\t\tif (eps.pointsSame(head, pt1)){\n\t\t\t\tif (setMatch(i, true, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(head, pt2)){\n\t\t\t\tif (setMatch(i, true, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt1)){\n\t\t\t\tif (setMatch(i, false, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt2)){\n\t\t\t\tif (setMatch(i, false, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (next_match === first_match){\n\t\t\t// we didn't match anything, so create a new chain\n\t\t\tchains.push([ pt1, pt2 ]);\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainNew(pt1, pt2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next_match === second_match){\n\t\t\t// we matched a single chain\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainMatch(first_match.index);\n\n\t\t\t// add the other point to the apporpriate end, and check to see if we've closed the\n\t\t\t// chain into a loop\n\n\t\t\tvar index = first_match.index;\n\t\t\tvar pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\t\t\tvar addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n\t\t\tvar chain = chains[index];\n\t\t\tvar grow  = addToHead ? chain[0] : chain[chain.length - 1];\n\t\t\tvar grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n\t\t\tvar oppo  = addToHead ? chain[chain.length - 1] : chain[0];\n\t\t\tvar oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n\t\t\tif (eps.pointsCollinear(grow2, grow, pt)){\n\t\t\t\t// grow isn't needed because it's directly between grow2 and pt:\n\t\t\t\t// grow2 ---grow---> pt\n\t\t\t\tif (addToHead){\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, pt);\n\t\t\t\t\tchain.shift();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, pt);\n\t\t\t\t\tchain.pop();\n\t\t\t\t}\n\t\t\t\tgrow = grow2; // old grow is gone... new grow is what grow2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsSame(oppo, pt)){\n\t\t\t\t// we're closing the loop, so remove chain from chains\n\t\t\t\tchains.splice(index, 1);\n\n\t\t\t\tif (eps.pointsCollinear(oppo2, oppo, grow)){\n\t\t\t\t\t// oppo isn't needed because it's directly between oppo2 and grow:\n\t\t\t\t\t// oppo2 ---oppo--->grow\n\t\t\t\t\tif (addToHead){\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, grow);\n\t\t\t\t\t\tchain.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, grow);\n\t\t\t\t\t\tchain.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainClose(first_match.index);\n\n\t\t\t\t// we have a closed chain!\n\t\t\t\tregions.push(chain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// not closing a loop, so just add it to the apporpriate side\n\t\t\tif (addToHead){\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddHead(first_match.index, pt);\n\t\t\t\tchain.unshift(pt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddTail(first_match.index, pt);\n\t\t\t\tchain.push(pt);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise, we matched two chains, so we need to combine those chains together\n\n\t\tfunction reverseChain(index){\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainReverse(index);\n\t\t\tchains[index].reverse(); // gee, that's easy\n\t\t}\n\n\t\tfunction appendChain(index1, index2){\n\t\t\t// index1 gets index2 appended to it, and index2 is removed\n\t\t\tvar chain1 = chains[index1];\n\t\t\tvar chain2 = chains[index2];\n\t\t\tvar tail  = chain1[chain1.length - 1];\n\t\t\tvar tail2 = chain1[chain1.length - 2];\n\t\t\tvar head  = chain2[0];\n\t\t\tvar head2 = chain2[1];\n\n\t\t\tif (eps.pointsCollinear(tail2, tail, head)){\n\t\t\t\t// tail isn't needed because it's directly between tail2 and head\n\t\t\t\t// tail2 ---tail---> head\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveTail(index1, tail);\n\t\t\t\tchain1.pop();\n\t\t\t\ttail = tail2; // old tail is gone... new tail is what tail2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsCollinear(tail, head, head2)){\n\t\t\t\t// head isn't needed because it's directly between tail and head2\n\t\t\t\t// tail ---head---> head2\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveHead(index2, head);\n\t\t\t\tchain2.shift();\n\t\t\t}\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainJoin(index1, index2);\n\t\t\tchains[index1] = chain1.concat(chain2);\n\t\t\tchains.splice(index2, 1);\n\t\t}\n\n\t\tvar F = first_match.index;\n\t\tvar S = second_match.index;\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainConnect(F, S);\n\n\t\tvar reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\t\tif (first_match.matches_head){\n\t\t\tif (second_match.matches_head){\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\tappendChain(S, F);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (second_match.matches_head){\n\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\tappendChain(F, S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn regions;\n}\n\nmodule.exports = SegmentChainer;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/segment-chainer.js?");

/***/ }),

/***/ "./node_modules/polybooljs/lib/segment-selector.js":
/*!*********************************************************!*\
  !*** ./node_modules/polybooljs/lib/segment-selector.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// filter a list of segments based on boolean operations\n//\n\nfunction select(segments, selection, buildLog){\n\tvar result = [];\n\tsegments.forEach(function(seg){\n\t\tvar index =\n\t\t\t(seg.myFill.above ? 8 : 0) +\n\t\t\t(seg.myFill.below ? 4 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.above) ? 2 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.below) ? 1 : 0);\n\t\tif (selection[index] !== 0){\n\t\t\t// copy the segment to the results, while also calculating the fill status\n\t\t\tresult.push({\n\t\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\t\tstart: seg.start,\n\t\t\t\tend: seg.end,\n\t\t\t\tmyFill: {\n\t\t\t\t\tabove: selection[index] === 1, // 1 if filled above\n\t\t\t\t\tbelow: selection[index] === 2  // 2 if filled below\n\t\t\t\t},\n\t\t\t\totherFill: null\n\t\t\t});\n\t\t}\n\t});\n\n\tif (buildLog)\n\t\tbuildLog.selected(result);\n\n\treturn result;\n}\n\nvar SegmentSelector = {\n\tunion: function(segments, buildLog){ // primary | secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 2, 0, 0,\n\t\t\t1, 0, 1, 0,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\tintersect: function(segments, buildLog){ // primary & secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled below    2\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   yes filled above    1\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled below    2\n\t\t//    1      1      1      0   =>   yes filled above    1\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 1, 0\n\t\t], buildLog);\n\t},\n\tdifference: function(segments, buildLog){ // primary - secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled below    2\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   yes filled above    1\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t2, 0, 2, 0,\n\t\t\t1, 1, 0, 0,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t},\n\tdifferenceRev: function(segments, buildLog){ // secondary - primary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled above    1\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   yes filled below    2\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\txor: function(segments, buildLog){ // primary ^ secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 0, 0, 1,\n\t\t\t1, 0, 0, 2,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t}\n};\n\nmodule.exports = SegmentSelector;\n\n\n//# sourceURL=webpack:///./node_modules/polybooljs/lib/segment-selector.js?");

/***/ }),

/***/ "./src/circle.js":
/*!***********************!*\
  !*** ./src/circle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Polygon = __webpack_require__(/*! ./polygon */ \"./src/polygon.js\");\nconst Vector2 = __webpack_require__(/*! ./vector2 */ \"./src/vector2.js\");\n\n/**\n * Circle Class\n * @extends Polygon\n */\nclass Circle extends Polygon {\n\t/**\n     * Create a circle polygon\n     * @param {Vector2} center The center of the circle\n     * @param {Number} radius The radius of the circle\n     * @param {Number} sides Sides count of the polygon circle\n     */\n\tconstructor(center, radius, sides) {\n\t\tsuper();\n\t\tthis._center = center;\n\t\tthis._radius = Math.abs(radius);\n\t\tthis._sides = parseInt(sides);\n\t\tif (this._sides < 3) {\n\t\t\tthis._sides = 3;\n\t\t}\n\t\tif (this._radius <= 0) {\n\t\t\tthis._radius = 1;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a circle\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t * @override\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsideCircle(point);\n\t}\n\n\t/**\n     * Check if a point is inside a Circle\n     * @param {Vector2} point The Vector2 like object\n     * @returns {Boolean}\n     */\n\tpointIsInsideCircle(point) {\n\t\treturn (Vector2.Distance(this._center, point) <= this._radius);\n\t}\n\n\t/**\n\t * Sides count of the circle\n\t * @type {Number}\n\t */\n\tget sides() {\n\t\treturn this._sides;\n\t}\n\n\tset sides(value) {\n\t\tthis._sides = parseInt(value);\n\t\tif (this._sides < 3) {\n\t\t\tthis._sides = 3;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\n\t/**\n\t * Center of the circle\n\t * @type {Vector2}\n\t */\n\tget center() {\n\t\treturn this._center;\n\t}\n\n\tset center(value) {\n\t\tthis._center = value;\n\t\tthis._calc();\n\t}\n\n\t/**\n\t * Radius of the circle\n\t * @type {Number}\n\t */\n\tget radius() {\n\t\treturn this._radius;\n\t}\n\n\tset radius(value) {\n\t\tthis._radius = value;\n\t\tif (this._radius <= 0) {\n\t\t\tthis._radius = 1;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\t_calc() {\n\t\tthis.first = null;\n\t\tfor (let i = 0; i < this._sides; i++) {\n\t\t\tthis.addVertex(new Vector2(0, this._radius).rotate(i / this._sides * 360).add(this._center));\n\t\t}\n\t}\n}\n\nmodule.exports = Circle;\n\n\n//# sourceURL=webpack:///./src/circle.js?");

/***/ }),

/***/ "./src/line.js":
/*!*********************!*\
  !*** ./src/line.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Vector2 = __webpack_require__(/*! ./vector2 */ \"./src/vector2.js\");\n\n/**\n * Line Class\n * @property {Vector2} start The start position of the line\n * @property {Vector2} end The end position of the line\n */\nclass Line {\n\t/**\n\t * @param {Vector2|Object} [p1] Vector2 like object of the start position\n\t * @param {Vector2|Object} [p2] Vector2 like object of the end position\n\t */\n\tconstructor(...args) {\n\t\tthis.start = new Vector2.Zero();\n\t\tthis.end = new Vector2.Zero();\n\t\tthis._checkParams(args);\n\t}\n\n\t/**\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn Vector2.Distance(this.end, this.start);\n\t}\n\n\t/**\n\t * Get the intersection of this line with an other one\n\t * Return false if lines does not intersect\n\t * @param {Line} line Second line\n\t * @returns boolean|Vector2\n\t */\n\tintersect(line) {\n\t\treturn Line.Intersect(this, line);\n\t}\n\n\t/**\n\t * Get a point on the line from start to end at lerpValue\n\t * @param {Number} lerpValue The lerp value, should be between 0 and 1, and it will be clamped\n\t * @returns Vector2\n\t */\n\talongPoint(lerpValue) {\n\t\treturn Vector2.Lerp(this.start, this.end, lerpValue);\n\t}\n\n\t/**\n\t * Get a point on the line from start to end at lerpValue (Unclamped version)\n\t * @param {Number} lerpValue The lerp value, should be between 0 and 1, but can be out of bound\n\t * @returns Vector2\n\t */\n\talongPointUnclamped(lerpValue) {\n\t\treturn Vector2.LerpUnclamped(this.start, this.end, lerpValue);\n\t}\n\n\t/**\n\t * Get the intersection of two lines\n\t * Return false if lines does not intersect\n\t * @param {Line} l1 First line\n\t * @param {Line} l2 Second line\n\t * @returns boolean|Vector2\n\t */\n\tstatic Intersect(l1, l2) {\n\t\tconst p0x = l1.start.x;\n\t\tconst p0y = l1.start.y;\n\t\tconst p1x = l1.end.x;\n\t\tconst p1y = l1.end.y;\n\t\tconst p2x = l2.start.x;\n\t\tconst p2y = l2.start.y;\n\t\tconst p3x = l2.end.x;\n\t\tconst p3y = l2.end.y;\n\t\tconst s1x = p1x - p0x;\n\t\tconst s1y = p1y - p0y;\n\t\tconst s2x = p3x - p2x;\n\t\tconst s2y = p3y - p2y;\n\n\t\tconst s = ((-s1y * (p0x - p2x)) + (s1x * (p0y - p2y))) / ((-s2x * s1y) + (s1x * s2y));\n\t\tconst t = ((s2x * (p0y - p2y)) - (s2y * (p0x - p2x))) / ((-s2x * s1y) + (s1x * s2y));\n\n\t\tconst p = new Vector2.Zero();\n\t\tif (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n\t\t\tp.x = p0x + (t * s1x);\n\t\t\tp.y = p0y + (t * s1y);\n\t\t\treturn p;\n\t\t}\n\t\treturn false;\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = Vector2.IsVector2Like(args[0]);\n\t\tconst p2 = Vector2.IsVector2Like(args[1]);\n\t\tif (p1 && p2) {\n\t\t\tthis.start = p1;\n\t\t\tthis.end = p2;\n\t\t} else if (p1) {\n\t\t\tthis.end = p1;\n\t\t}\n\t}\n}\n\nmodule.exports = Line;\n\n\n//# sourceURL=webpack:///./src/line.js?");

/***/ }),

/***/ "./src/polygon.js":
/*!************************!*\
  !*** ./src/polygon.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst PolyBool = __webpack_require__(/*! polybooljs */ \"./node_modules/polybooljs/index.js\");\n\nconst Line = __webpack_require__(/*! ./line */ \"./src/line.js\");\nconst Vector2 = __webpack_require__(/*! ./vector2 */ \"./src/vector2.js\");\n/**\n * Polygon Class\n * @property {Vector2} first The first point of the polygon, follow next on first to iterate\n */\nclass Polygon {\n\t/**\n\t * Create a new Polygon\n\t * @param {Vector2[]} [vertices] Vertices of the polygon\n\t */\n\tconstructor(vertices = []) {\n\t\tthis.children = [];\n\t\tthis.first = null;\n\t\tif (vertices && vertices.length) {\n\t\t\tfor (const vertice of vertices) {\n\t\t\t\tthis.addVertex(vertice);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a polygon\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsidePolygon(point);\n\t}\n\n\t/**\n\t * Checking if point is inside a polygon\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t */\n\tpointIsInsidePolygon(point) {\n\t\tlet oddNodes = false;\n\t\tlet vertex = this.first;\n\t\tlet next = vertex.next;\n\t\tconst x = point.x;\n\t\tconst y = point.y;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t(vertex.y < y && next.y >= y) ||\n\t\t\t\t\t(next.y < y && vertex.y >= y)\n\t\t\t\t) &&\n\t\t\t\t(vertex.x <= x || next.x <= x)\n\t\t\t) {\n\t\t\t\toddNodes ^= (vertex.x + ((y - vertex.y) /\n\t\t\t\t\t(next.y - vertex.y) * (next.x - vertex.x)) < x);\n\t\t\t}\n\t\t\tvertex = vertex.next;\n\t\t\tnext = vertex.next || this.first;\n\t\t} while (!vertex.equals(this.first));\n\t\treturn oddNodes;\n\t}\n\n\t/**\n\t * Setting all children polygons (for holes)\n\t * @param {Polygon[]} polygons Children to set\n\t * @returns {Polygon}\n\t */\n\tsetChildren(polygons) {\n\t\tthis.children = polygons;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding a child polygon (for hole)\n\t * @param {Polygon} polygon Child polygon to add\n\t * @returns {Polygon}\n\t */\n\taddChild(polygon) {\n\t\tthis.children.push(polygon);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting vertices of the polygon\n\t * @param {Vector2[]} vertices Vertices to set\n\t * @returns {Polygon}\n\t */\n\tsetVertexes(vertices) {\n\t\tthis.first = null;\n\t\tfor (const v of vertices) {\n\t\t\tthis.addVertex(v);\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Add a new vertices to the end\n\t * @param {Vector2} vertice the vertice to add\n\t * @returns {Polygon}\n\t */\n\taddVertex(vertice) {\n\t\tif (this.first === null) {\n\t\t\tthis.first = vertice;\n\t\t\tthis.first.next = vertice;\n\t\t\tthis.first.prev = vertice;\n\t\t} else {\n\t\t\tconst next = this.first;\n\t\t\tconst prev = next.prev;\n\n\t\t\tnext.prev = vertice;\n\t\t\tvertice.next = next;\n\t\t\tvertice.prev = prev;\n\t\t\tprev.next = vertice;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Is the current polygon colliding with the given polygon\n\t * @param {Polygon} polygon the second polygon for the collision\n\t * @returns {Boolean}\n\t */\n\tcolliding(polygon) {\n\t\treturn Polygon.Colliding(this, polygon);\n\t}\n\n\t/**\n\t * Intersect boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tintersect(polygon) {\n\t\treturn Polygon.Intersect(this, polygon);\n\t}\n\n\t/**\n\t * Difference boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tdifference(p) {\n\t\treturn Polygon.Difference(this, p);\n\t}\n\n\t/**\n\t * Union boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tunion(p) {\n\t\treturn Polygon.Union(this, p);\n\t}\n\n\t/**\n\t * Xor boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\txor(p) {\n\t\treturn Polygon.Xor(this, p);\n\t}\n\n\n\t/* GETTERS */\n\t/**\n\t * Get region for polybooljs plugin, can be also be used for GeoJson.\n\t * Return a double level array ([[x, y], [x, y], ...])\n\t * @type {Array[]}\n\t * @readonly\n\t */\n\tget region() {\n\t\treturn this.points.map((p) => {\n\t\t\treturn [p.x, p.y];\n\t\t});\n\t}\n\n\t/**\n\t * Get points of the Polygon\n\t * @type {Vector2[]}\n\t * @readonly\n\t */\n\tget points() {\n\t\tconst points = [];\n\t\tlet v = this.first;\n\n\t\tdo {\n\t\t\tpoints.push(v);\n\t\t\tv = v.next;\n\t\t} while (!v.equals(this.first));\n\t\treturn points;\n\t}\n\n\t/**\n\t * Get lines of the Polygon\n\t * @type {Line[]}\n\t * @readonly\n\t */\n\tget lines() {\n\t\tconst lines = [];\n\t\tlet prev = null;\n\t\tlet cur = this.first;\n\t\tdo {\n\t\t\tif (prev !== null) {\n\t\t\t\tlines.push(new Line(prev, cur));\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur.next;\n\t\t} while (!cur.equals(this.first));\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Get area of the Polygon\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget area() {\n\t\tlet total = 0;\n\t\tlet v = this.first;\n\t\tdo {\n\t\t\ttotal += (v.x * v.next.y) - (v.y * v.next.x);\n\t\t\tv = v.next;\n\t\t} while (!v.equals(this.first));\n\n\t\tlet area = total / 2;\n\t\tif (this.children && this.children.length) {\n\t\t\tfor (const child of this.children) {\n\t\t\t\tarea -= child.area;\n\t\t\t}\n\t\t}\n\t\treturn Math.abs(area);\n\t}\n\n\t/**\n\t * Is the p1 polygon colliding with the p2 polygon\n\t * @param {Polygon} p1 the first polygon for the collision\n\t * @param {Polygon} p2 the second polygon for the collision\n\t * @returns {Boolean}\n\t */\n\tstatic Colliding(p1, p2) {\n\t\tconst p1Points = p1.points;\n\t\tconst p2Points = p2.points;\n\t\tfor (const pt1 of p1Points) {\n\t\t\tif (p2.pointIsInside(pt1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (const pt2 of p2Points) {\n\t\t\tif (p1.pointIsInside(pt2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Convert region to polygon\n\t * @param {Array[]} region the region to convert\n\t * @returns {Polygon}\n\t */\n\tstatic FromRegion(region) {\n\t\treturn new Polygon(region.map((p) => {\n\t\t\treturn new Vector2(p[0], p[1]);\n\t\t}));\n\t}\n\n\n\t/**\n\t * Intersect boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Intersect(p1, p2) {\n\t\tconst operation = PolyBool.intersect({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Union boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Union(p1, p2) {\n\t\tconst operation = PolyBool.union({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Difference boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Difference(p1, p2) {\n\t\tconst operation = PolyBool.difference({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Xor boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Xor(p1, p2) {\n\t\tconst operation = PolyBool.xor({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n}\n\nmodule.exports = Polygon;\n\n\n//# sourceURL=webpack:///./src/polygon.js?");

/***/ }),

/***/ "./src/rect.js":
/*!*********************!*\
  !*** ./src/rect.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Vector2 = __webpack_require__(/*! ./vector2 */ \"./src/vector2.js\");\nconst Polygon = __webpack_require__(/*! ./polygon */ \"./src/polygon.js\");\n/**\n * Rect Class\n * @extends Polygon\n * @property {Vector2} position\n * @property {Vector2} size\n */\nclass Rect extends Polygon {\n\t/**\n\t * @param {Vector2|Object|Number} [p1] Vector2 like object of the start position | position.x\n\t * @param {Vector2|Object|Number} [p2] Vector2 like object of the size | position.y\n\t * @param {Number} [p3] size.x\n\t * @param {Number} [p4] size.y\n\t */\n\tconstructor(...args) {\n\t\tsuper();\n\t\tthis._position = Vector2.zero;\n\t\tthis._size = Vector2.zero;\n\t\tthis._checkParams(args);\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a rect\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t * @override\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsideRect(point);\n\t}\n\n\t/**\n     * Check if a point is inside a Rect\n     * @param {Vector2} point The Vector2 like object\n     * @returns {Boolean}\n     */\n\tpointIsInsideRect(point) {\n\t\tconst ps = this._position;\n\t\tconst pe = this._position.clone.add(this._size);\n\t\tconst pmin = new Vector2(\n\t\t\tMath.min(ps.x, pe.x),\n\t\t\tMath.min(ps.y, pe.y)\n\t\t);\n\t\tconst pmax = new Vector2(\n\t\t\tMath.max(ps.x, pe.x),\n\t\t\tMath.max(ps.y, pe.y)\n\t\t);\n\t\tif (\n\t\t\tpoint.x >= pmin.x &&\n\t\t\tpoint.x <= pmax.x &&\n\t\t\tpoint.y >= pmin.y &&\n\t\t\tpoint.y <= pmax.y\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * The start position of the rect\n     * @type {Vector2}\n     */\n\tget position() {\n\t\treturn this._position;\n\t}\n\n\t/**\n\t * The size of the rect\n     * @type {Vector2}\n     */\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\tset position(value) {\n\t\tthis._position = value;\n\t\tthis._calcPoly();\n\t}\n\n\tset size(value) {\n\t\tthis._size = value;\n\t\tthis._calcPoly();\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = Vector2.IsVector2Like(args[0]) || args[0];\n\t\tconst p2 = Vector2.IsVector2Like(args[1]) || args[1];\n\t\tconst p3 = args[2];\n\t\tconst p4 = args[3];\n\t\tif (\n\t\t\tp1 && typeof p1 === 'object' &&\n\t\t\tp2 && typeof p2 === 'object'\n\t\t) { // (Vector2 position, Vector2 size)\n\t\t\tthis._position = p1;\n\t\t\tthis._size = p2;\n\t\t} else if (\n\t\t\tp1 && typeof p1 !== 'undefined' && typeof p1 !== 'object' &&\n\t\t\tp2 && typeof p2 !== 'undefined' && typeof p2 !== 'object' &&\n\t\t\tp3 && typeof p3 !== 'undefined' && typeof p3 !== 'object' &&\n\t\t\tp4 && typeof p4 !== 'undefined' && typeof p4 !== 'object'\n\t\t) { // (Vector2 position, Vector2 size)\n\t\t\tthis._position.x = p1;\n\t\t\tthis._position.y = p2;\n\t\t\tthis._size.x = p3;\n\t\t\tthis._size.y = p4;\n\t\t}\n\t\tthis._calcPoly();\n\t}\n\n\t_calcPoly() {\n\t\tthis.setVertexes([\n\t\t\tthis._position,\n\t\t\tthis._position.clone.add(new Vector2(this._size.x, 0)),\n\t\t\tthis._position.clone.add(this._size),\n\t\t\tthis._position.clone.add(new Vector2(0, this._size.y))\n\t\t]);\n\t}\n\n\t/**\n     * Get the box around a polygon or around points\n     * @param {Polygon|Vector2[]} p The polygon, or array of Vector2\n     * @returns {Rect}\n     */\n\tstatic Box(p) {\n\t\tif (p && typeof p === 'object') {\n\t\t\tif (p instanceof Polygon) {\n\t\t\t\tp = p.points;\n\t\t\t}\n\t\t\tif (p instanceof Array && p.length) {\n\t\t\t\tconst xs = p.map(_ => _.x);\n\t\t\t\tconst ys = p.map(_ => _.y);\n\t\t\t\tconst position = new Vector2(Math.min(...xs), Math.min(...ys));\n\t\t\t\tconst size = new Vector2(Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));\n\t\t\t\treturn new Rect(position, size);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\nmodule.exports = Rect;\n\n\n//# sourceURL=webpack:///./src/rect.js?");

/***/ }),

/***/ "./src/vector2.js":
/*!************************!*\
  !*** ./src/vector2.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Vector2 Class\n * @property {Number} x The x value of the vertice\n * @property {Number} y The y value of the vertice\n */\nclass Vector2 {\n\t/**\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * // returns Vector2 with x:0 & y:0\n\t * new Vector2()\n\t * @example\n\t * // returns Vector2 with x:2 & y:2\n\t * new Vector2(2)\n\t * @example\n\t * // returns Vector2 with x:4 & y:5\n\t * new Vector2(4, 5)\n\t * @example\n\t * // returns Vector2 with x:1 & y:3\n\t * new Vector2({x: 1, y: 3})\n\t * @example\n\t * // returns Vector2 with x:6 & y:7\n\t * const v1 = new Vector2(6, 7);\n\t * new Vector2(v1);\n\t * @constructor\n\t */\n\tconstructor(...args) {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tconst pos = this._checkParams(args);\n\t\tthis.x = pos.x;\n\t\tthis.y = pos.y;\n\t\tthis.next = null;\n\t\tthis.prev = null;\n\t}\n\n\t/**\n\t * Flooring the Vector2\n\t * @param {Number} v=1 Precision\n\t * @returns {Vector2}\n\t */\n\tfloor(v = 1) {\n\t\tthis.floorX(v);\n\t\tthis.floorY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Flooring the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tfloorX(v = 1) {\n\t\tthis.x = Math.floor(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Flooring the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tfloorY(v = 1) {\n\t\tthis.y = Math.floor(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Ceiling the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceil(v = 1) {\n\t\tthis.ceilX(v);\n\t\tthis.ceilY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ceiling the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceilX(v = 1) {\n\t\tthis.x = Math.ceil(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ceiling the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceilY(v = 1) {\n\t\tthis.y = Math.ceil(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tround(v = 1) {\n\t\tthis.roundX(v);\n\t\tthis.roundY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\troundX(v = 1) {\n\t\tthis.x = Math.round(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\troundY(v = 1) {\n\t\tthis.y = Math.round(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the value of the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:3 & y:3\n\t * v1.set(3);\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:3 & y:4\n\t * v1.set(3, 4);\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:5 & y:6\n\t * v1.set({x:5, y:6});\n\t * @example\n\t * const v1 = new Vector2();\n\t * const v2 = new Vector2(7, 8);\n\t * // change v1 Vector2 to x:7 & y:8\n\t * v1.set(v2);\n\t * @returns {Vector2}\n\t */\n\tset(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.setX(pos.x);\n\t\tthis.setY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsetX(v) {\n\t\tthis.x = v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the y value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsetY(v) {\n\t\tthis.y = v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add  3 to v1 Vector2\n\t * v1.add(3);\n\t * // v1 values are now x:5 & y:6\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add 5, 7 to v1 Vector2\n\t * v1.add(5, 7);\n\t * // v1 values are now x:7 & y:10\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add  3 to v1 Vector2\n\t * v1.add({x:1, y:2});\n\t * // v1 values are now x:3 & y:5\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // add  3 to v1 Vector2\n\t * v1.add(v2);\n\t * // v1 values are now x:6 & y:4, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tadd(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.addX(pos.x);\n\t\tthis.addY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\taddX(v) {\n\t\tthis.x += v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adding v to y value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\taddY(v) {\n\t\tthis.y += v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Substracting values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting  3 to v1 Vector2\n\t * v1.substract(3);\n\t * // v1 values are now x:-1 & y:0\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting 5, 7 to v1 Vector2\n\t * v1.substract(5, 7);\n\t * // v1 values are now x:-3 & y:-4\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting  3 to v1 Vector2\n\t * v1.substract({x:1, y:2});\n\t * // v1 values are now x:1 & y:1\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // Substracting 3 to v1 Vector2\n\t * v1.substract(v2);\n\t * // v1 values are now x:-2 & y:2, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tsubstract(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.substractX(pos.x);\n\t\tthis.substractY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Substracting v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsubstractX(v) {\n\t\tthis.x -= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Substracting v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsubstractY(v) {\n\t\tthis.y -= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Multiply values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply 3 to v1 Vector2\n\t * v1.multiply(3);\n\t * // v1 values are now x:6 & y:9\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply 5, 7 to v1 Vector2\n\t * v1.multiply(5, 7);\n\t * // v1 values are now x:10 & y:21\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply  1, 2 to v1 Vector2\n\t * v1.multiply({x:1, y:2});\n\t * // v1 values are now x:2 & y:6\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // Multiply v2 to v1 Vector2\n\t * v1.multiply(v2);\n\t * // v1 values are now x:8 & y:3, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tmultiply(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.multiplyX(pos.x);\n\t\tthis.multiplyY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Multiply x value of the Vector2 by v\n\t * @param {Number} v The multiplicator\n\t * @returns {Vector2}\n\t */\n\tmultiplyX(v) {\n\t\tthis.x *= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Multiply y value of the Vector2 by v\n\t * @param {Number} v The multiplicator\n\t * @returns {Vector2}\n\t */\n\tmultiplyY(v) {\n\t\tthis.y *= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Dividing values to the the Vector2\n\t * @param {Vector2|Number} p1 Vector2: copy, Number: assign\n\t * @param {Number} p2 Number: assign\n\t * @example\n\t * const v1 = new Vector2(12, 9);\n\t * // Dividing v1 Vector2 by 3\n\t * v1.divide(3);\n\t * // v1 values are now x:4 & y:3\n\t * @example\n\t * const v1 = new Vector2(10, 15);\n\t * // Dividing v1 Vector2 by 2, 5\n\t * v1.divide(2, 5);\n\t * // v1 values are now x:5 & y:3\n\t * @example\n\t * const v1 = new Vector2(5, 8);\n\t * // Dividing v1 Vector2 by 2, 4\n\t * v1.divide({x:2, y:4});\n\t * // v1 values are now x:2.5 & y:2\n\t * @example\n\t * const v1 = new Vector2(12, 10);\n\t * const v2 = new Vector2(6, 2);\n\t * // Dividing v1 Vector2 by 6, 2\n\t * v1.divide(v2);\n\t * // v1 values are now x:2 & y:5, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tdivide(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.divideX(pos.x);\n\t\tthis.divideY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Divinding x value of the Vector2 by v\n\t * @param {Number} v The divisor\n\t * @returns {Vector2}\n\t */\n\tdivideX(v) {\n\t\tthis.x /= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Divinding x value of the Vector2 by v\n\t * @param {Number} v The divisor\n\t * @returns {Vector2}\n\t */\n\tdivideY(v) {\n\t\tthis.y /= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Inverting the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invert();\n\t * // v1 values are now x:-3 & y:-6\n\t * @returns {Vector2}\n\t */\n\tinvert() {\n\t\tthis.invertX();\n\t\tthis.invertY();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inverting the x value of the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invertX();\n\t * // v1 values are now x:-3 & y:6\n\t * @returns {Vector2}\n\t */\n\tinvertX() {\n\t\tthis.x = 0 - this.x;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inverting the y value of the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invertY();\n\t * // v1 values are now x:3 & y:-6\n\t * @returns {Vector2}\n\t */\n\tinvertY() {\n\t\tthis.y = 0 - this.y;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Rotate the Vector2 arround zero by angle\n\t * @param {Number} angle degrees angle\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.rotate(180);\n\t * // v1 values are now x:-3 & y:-6\n\t * @returns {Vector2}\n\t */\n\trotate(angle) {\n\t\tangle = angle * (Math.PI / 180);\n\t\tconst cos = Math.cos(angle);\n\t\tconst sin = Math.sin(angle);\n\t\tconst x = this.x * 1;\n\t\tconst y = this.y * 1;\n\t\tthis.x = ((x * cos) - (y * sin));\n\t\tthis.y = ((x * sin) + (y * cos));\n\t\tthis.approximate();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Test if the Vector2 is equal to an other\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equals(v2); // false\n\t * @returns {Boolean}\n\t */\n\tequals(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\treturn this.equalsX(pos.x) && this.equalsY(pos.y);\n\t}\n\n\t/**\n\t * Test if the x value of the Vector2 is equal to an other\n\t * @param {Number} v The value to compare\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equalsX(v2); // false\n\t * @returns {Boolean}\n\t */\n\tequalsX(v) {\n\t\treturn this.x === v;\n\t}\n\n\t/**\n\t * Test if the y value of the Vector2 is equal to an other\n\t * @param {Number} v The value to compare\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equalsY(v2); // true\n\t * @returns {Boolean}\n\t */\n\tequalsY(v) {\n\t\treturn this.y === v;\n\t}\n\n\t/**\n\t * Test if the current Vector2 is inside a polygon\n\t * @param {Polygon} polygon The polygon to check\n\t * @example\n\t * const polygon = new Polygon([\n\t * \tnew Vector2(0,0),\n\t * \tnew Vector2(10,0),\n\t * \tnew Vector2(10,10),\n\t * \tnew Vector2(0,10)\n\t * ]);\n\t * const v1 = new Vector2(5, 5);\n\t * return v1.isInside(polygon); // true\n\t * @returns {Boolean}\n\t */\n\tisInside(polygon) {\n\t\treturn polygon.pointIsInside(this);\n\t}\n\n\t/**\n\t * @see {@link approximated}\n\t * @example\n\t * const v1 = new Vector2(Math.PI, Math.PI);\n\t * console.log(v1.toString()); // {x: 3.141592653589793, y: 3.141592653589793}\n\t * console.log(v1.approximate().toString()); // {x: 3.1416, y: 3.1416}\n\t */\n\tapproximate() {\n\t\tthis.setX(Math.round(this.x * 10000) / 10000).setY(Math.round(this.y * 10000) / 10000);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Approximated value of the Vector2 (used to remove duplicates)\n\t * @see {@link approximate}\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(Math.PI, Math.PI);\n\t * console.log(v1.toString()); // {x: 3.141592653589793, y: 3.141592653589793}\n\t * console.log(v1.approximate.toString()); // {x: 3.1416, y: 3.1416}\n\t */\n\tget approximated() {\n\t\treturn this.clone.approximate();\n\t}\n\n\t/**\n\t * Normalized Vector2\n\t * @see {@link norm}\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(1, 1);\n\t * console.log(v1.normalized.toString()); // {x: 0.7071067811865476, y: 0.7071067811865476}\n\t */\n\tget normalized() {\n\t\treturn this.divide(this.magnitude);\n\t}\n\n\t/**\n\t * Alias of normalized\n\t * @see {@link normalized}\n     * @readonly\n\t * @type {Vector2}\n\t */\n\tget norm() {\n\t\treturn this.normalized;\n\t}\n\n\t/**\n\t * Magnitude of the Vector2\n\t * @type {Number}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(12, 32);\n\t * console.log(v1.magnitude); // 34.17601498127012\n\t */\n\tget magnitude() {\n\t\treturn Math.sqrt((this.x * this.x) + (this.y * this.y));\n\t}\n\n\t/**\n\t * A clone of the Vector2\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(5, 5);\n\t * console.log(v1.clone.add(2, 3)); // {x: 7, y: 8}\n\t * // v1 is unchanged\n\t */\n\tget clone() {\n\t\treturn new Vector2(this.x, this.y);\n\t}\n\n\t/**\n\t * Getting JSON string version of the Vector2\n\t * @returns {String}\n\t */\n\ttoString() {\n\t\treturn JSON.stringify({\n\t\t\tx: this.x,\n\t\t\ty: this.y\n\t\t});\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = args[0];\n\t\tconst p2 = args[1];\n\t\tconst pos = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tif (p1 !== null && typeof p1 === 'object') {\n\t\t\tif (typeof p1.x !== 'undefined' && typeof p1.y !== 'undefined') {\n\t\t\t\tpos.x = p1.x * 1;\n\t\t\t\tpos.y = p1.y * 1;\n\t\t\t}\n\t\t} else if (typeof p1 !== 'undefined' && typeof p2 !== 'undefined') {\n\t\t\tpos.x = p1 * 1;\n\t\t\tpos.y = p2 * 1;\n\t\t} else if (typeof p1 !== 'undefined') {\n\t\t\tpos.x = p1 * 1;\n\t\t\tpos.y = p1 * 1;\n\t\t}\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Getting the distance between two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Number}\n\t */\n\tstatic Distance(v1, v2) {\n\t\tconst dx = Math.abs(v1.x - v2.x);\n\t\tconst dy = Math.abs(v1.y - v2.y);\n\t\treturn Math.sqrt((dx * dx) + (dy * dy));\n\t}\n\n\t/**\n\t * Getting the max values from two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Vector2}\n\t */\n\tstatic Max(v1, v2) {\n\t\treturn new Vector2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y));\n\t}\n\n\t/**\n\t * Getting the min values from two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Vector2}\n\t */\n\tstatic Min(v1, v2) {\n\t\treturn new Vector2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y));\n\t}\n\n\t/**\n\t * Getting a Lerp Vector2 from v1 to v2 with t time\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @param {Number} t time of lerp, value should be between 0 and 1\n\t * @returns {Vector2}\n\t */\n\tstatic Lerp(v1, v2, t) {\n\t\tif (t > 1) {\n\t\t\tt = 1;\n\t\t} else if (t < 0) {\n\t\t\tt = 0;\n\t\t}\n\t\treturn Vector2.LerpUnclamped(v1, v2, t);\n\t}\n\n\t/**\n\t * Getting a Lerp Vector2 from v1 to v2 with t time (Unclamped version)\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @param {Number} t time of lerp, value should be between 0 and 1, but it can exceed this values\n\t * @returns {Vector2}\n\t */\n\tstatic LerpUnclamped(v1, v2, t) {\n\t\tconst diffV = v2.clone.substract(v1).multiply(t);\n\t\treturn v1.clone.add(diffV);\n\t}\n\n\t/**\n\t * Test if the passed element is a Vector2 like and return Vector2 corresponding, or false\n\t * @param {any} subject The subject to test\n\t * @returns {Vector2|false} false on failure\n\t */\n\tstatic IsVector2Like(subject) {\n\t\tif (\n\t\t\ttypeof subject === 'object' &&\n\t\t\ttypeof subject.x !== 'undefined' &&\n\t\t\ttypeof subject.y !== 'undefined'\n\t\t) {\n\t\t\tif (subject instanceof Vector2) {\n\t\t\t\treturn subject;\n\t\t\t} else {\n\t\t\t\treturn new Vector2(subject);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n/**\n * A zero Vector2\n * @returns {Vector2}\n */\nVector2.Zero = function() {\n\treturn new Vector2(0, 0);\n};\n\n/**\n * A top Vector2\n * @returns {Vector2}\n */\nVector2.Top = function() {\n\treturn new Vector2(0, -1);\n};\n\n/**\n * A left Vector2\n * @returns {Vector2}\n */\nVector2.Left = function() {\n\treturn new Vector2(-1, 0);\n};\n\n/**\n * A bottom Vector2\n * @returns {Vector2}\n */\nVector2.Bottom = function() {\n\treturn new Vector2(0, 1);\n};\n\n/**\n * A right Vector2\n * @returns {Vector2}\n */\nVector2.Right = function() {\n\treturn new Vector2(1, 0);\n};\n\nmodule.exports = Vector2;\n\n\n//# sourceURL=webpack:///./src/vector2.js?");

/***/ })

/******/ });