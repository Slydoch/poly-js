{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector2.js","webpack:///./src/polygon.js","webpack:///./src/line.js","webpack:///./index.js","webpack:///./node_modules/polybooljs/index.js","webpack:///./node_modules/polybooljs/lib/build-log.js","webpack:///./node_modules/polybooljs/lib/epsilon.js","webpack:///./node_modules/polybooljs/lib/intersecter.js","webpack:///./node_modules/polybooljs/lib/linked-list.js","webpack:///./node_modules/polybooljs/lib/segment-chainer.js","webpack:///./node_modules/polybooljs/lib/segment-selector.js","webpack:///./node_modules/polybooljs/lib/geojson.js","webpack:///./src/rect.js","webpack:///./src/circle.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector2","this","x","y","args","pos","_checkParams","next","prev","v1","v2","dx","Math","abs","dy","sqrt","max","min","LerpUnclamped","diffV","clone","substract","multiply","add","subject","v","floorX","floorY","floor","ceilX","ceilY","ceil","roundX","roundY","round","setX","setY","addX","addY","substractX","substractY","multiplyX","multiplyY","divideX","divideY","invertX","invertY","angle","PI","cos","sin","approximate","equalsX","equalsY","polygon","pointIsInside","JSON","stringify","p1","p2","divide","magnitude","normalized","Zero","Top","Left","Bottom","Right","PolyBool","require","Line","Polygon","vertices","children","first","length","vertice","addVertex","p1Points","points","p2Points","pt1","pt2","region","map","intersect","regions","inverted","FromRegion","union","difference","xor","point","pointIsInsidePolygon","oddNodes","vertex","equals","polygons","push","Colliding","Intersect","Difference","Union","Xor","lines","cur","total","area","start","end","l1","l2","p0x","p0y","p1x","p1y","p2x","p2y","s1x","s1y","s2x","s2y","line","lerpValue","Lerp","IsVector2Like","Distance","Rect","Circle","BuildLog","Epsilon","Intersecter","SegmentChainer","SegmentSelector","GeoJSON","buildLog","epsilon","operate","poly1","poly2","selector","seg1","segments","seg2","seg3","combine","bl","list","poly","forEach","addRegion","calculate","segments1","segments2","combined","inverted1","inverted2","selectUnion","selectIntersect","selectDifference","selectDifferenceRev","differenceRev","selectXor","polygonFromGeoJSON","geojson","toPolygon","polygonToGeoJSON","fromPolygon","window","my","nextSegmentId","curVert","type","data","parse","segmentId","checkIntersection","segmentChop","seg","pt","statusRemove","segmentUpdate","segmentNew","primary","segmentRemove","tempStatus","above","below","rewind","status","vert","log","txt","reset","selected","segs","chainStart","chainRemoveHead","index","chainRemoveTail","chainNew","chainMatch","chainClose","chainAddHead","chainAddTail","chainConnect","index1","index2","chainReverse","chainJoin","done","eps","pointAboveOrOnLine","left","right","Ax","Ay","Bx","By","Cx","pointBetween","d_py_ly","d_rx_lx","d_px_lx","d_ry_ly","dot","pointsSameX","pointsSameY","pointsSame","pointsCompare","pointsCollinear","pt3","dx1","dy1","dx2","dy2","linesIntersect","a0","a1","b0","b1","adx","ady","bdx","bdy","axb","A","B","ret","alongA","alongB","pointInsideRegion","last_x","last_y","inside","curr_x","curr_y","LinkedList","selfIntersection","segmentCopy","id","myFill","otherFill","event_root","eventAdd","ev","other_pt","insertBefore","here","p1_isStart","p1_1","p1_2","p2_isStart","p2_1","p2_2","comp","eventCompare","isStart","other","eventAddSegment","ev_start","node","eventAddSegmentStart","ev_end","eventAddSegmentEnd","eventDivide","remove","eventUpdateEnd","primaryPolyInverted","secondaryPolyInverted","status_root","statusFindSurrounding","findTransition","ev1","ev2","a2","b2","a1_equ_b1","a2_equ_b2","a1_between","a2_between","isEmpty","getHead","surrounding","before","after","checkBothIntersections","eve","toggle","insert","st","Error","exists","forward","root","check","last","chains","console","warn","first_match","matches_head","matches_pt1","second_match","next_match","head","chain","tail","setMatch","addToHead","grow","grow2","oppo","oppo2","shift","pop","splice","unshift","F","S","reverseF","reverseChain","appendChain","reverse","chain1","chain2","tail2","head2","concat","select","selection","result","GeoPoly","coords","LineString","ls","reg","slice","out","coordinates","regionInsideRegion","r1","r2","newNode","roots","addChild","child","forceWinding","clockwise","winding","copy","geopolys","addExterior","getInterior","_position","zero","_size","Array","xs","_","ys","pointIsInsideRect","ps","pe","pmin","pmax","p3","p4","_calcPoly","setVertexes","center","radius","sides","_center","_radius","_sides","parseInt","_calc","pointIsInsideCircle","rotate"],"mappings":"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","file":"poly-js.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","'use strict';\n/**\n * Vector2 Class\n * @property {Number} x The x value of the vertice\n * @property {Number} y The y value of the vertice\n */\nclass Vector2 {\n\t/**\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * // returns Vector2 with x:0 & y:0\n\t * new Vector2()\n\t * @example\n\t * // returns Vector2 with x:2 & y:2\n\t * new Vector2(2)\n\t * @example\n\t * // returns Vector2 with x:4 & y:5\n\t * new Vector2(4, 5)\n\t * @example\n\t * // returns Vector2 with x:1 & y:3\n\t * new Vector2({x: 1, y: 3})\n\t * @example\n\t * // returns Vector2 with x:6 & y:7\n\t * const v1 = new Vector2(6, 7);\n\t * new Vector2(v1);\n\t * @constructor\n\t */\n\tconstructor(...args) {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tconst pos = this._checkParams(args);\n\t\tthis.x = pos.x;\n\t\tthis.y = pos.y;\n\t\tthis.next = null;\n\t\tthis.prev = null;\n\t}\n\n\t/**\n\t * Flooring the Vector2\n\t * @param {Number} v=1 Precision\n\t * @returns {Vector2}\n\t */\n\tfloor(v = 1) {\n\t\tthis.floorX(v);\n\t\tthis.floorY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Flooring the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tfloorX(v = 1) {\n\t\tthis.x = Math.floor(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Flooring the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tfloorY(v = 1) {\n\t\tthis.y = Math.floor(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Ceiling the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceil(v = 1) {\n\t\tthis.ceilX(v);\n\t\tthis.ceilY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ceiling the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceilX(v = 1) {\n\t\tthis.x = Math.ceil(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ceiling the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tceilY(v = 1) {\n\t\tthis.y = Math.ceil(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\tround(v = 1) {\n\t\tthis.roundX(v);\n\t\tthis.roundY(v);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the x value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\troundX(v = 1) {\n\t\tthis.x = Math.round(this.x * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounding the y value of the Vector2\n\t * @param {Number} [v=1] Precision\n\t * @returns {Vector2}\n\t */\n\troundY(v = 1) {\n\t\tthis.y = Math.round(this.y * v) / v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the value of the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:3 & y:3\n\t * v1.set(3);\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:3 & y:4\n\t * v1.set(3, 4);\n\t * @example\n\t * const v1 = new Vector2();\n\t * // change v1 Vector2 to x:5 & y:6\n\t * v1.set({x:5, y:6});\n\t * @example\n\t * const v1 = new Vector2();\n\t * const v2 = new Vector2(7, 8);\n\t * // change v1 Vector2 to x:7 & y:8\n\t * v1.set(v2);\n\t * @returns {Vector2}\n\t */\n\tset(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.setX(pos.x);\n\t\tthis.setY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsetX(v) {\n\t\tthis.x = v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting the y value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsetY(v) {\n\t\tthis.y = v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add  3 to v1 Vector2\n\t * v1.add(3);\n\t * // v1 values are now x:5 & y:6\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add 5, 7 to v1 Vector2\n\t * v1.add(5, 7);\n\t * // v1 values are now x:7 & y:10\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // add  3 to v1 Vector2\n\t * v1.add({x:1, y:2});\n\t * // v1 values are now x:3 & y:5\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // add  3 to v1 Vector2\n\t * v1.add(v2);\n\t * // v1 values are now x:6 & y:4, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tadd(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.addX(pos.x);\n\t\tthis.addY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\taddX(v) {\n\t\tthis.x += v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adding v to y value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\taddY(v) {\n\t\tthis.y += v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Substracting values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting  3 to v1 Vector2\n\t * v1.substract(3);\n\t * // v1 values are now x:-1 & y:0\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting 5, 7 to v1 Vector2\n\t * v1.substract(5, 7);\n\t * // v1 values are now x:-3 & y:-4\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Substracting  3 to v1 Vector2\n\t * v1.substract({x:1, y:2});\n\t * // v1 values are now x:1 & y:1\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // Substracting 3 to v1 Vector2\n\t * v1.substract(v2);\n\t * // v1 values are now x:-2 & y:2, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tsubstract(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.substractX(pos.x);\n\t\tthis.substractY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Substracting v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsubstractX(v) {\n\t\tthis.x -= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Substracting v to x value of the Vector2\n\t * @param {Number} v The value\n\t * @returns {Vector2}\n\t */\n\tsubstractY(v) {\n\t\tthis.y -= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Multiply values to the the Vector2\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply 3 to v1 Vector2\n\t * v1.multiply(3);\n\t * // v1 values are now x:6 & y:9\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply 5, 7 to v1 Vector2\n\t * v1.multiply(5, 7);\n\t * // v1 values are now x:10 & y:21\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * // Multiply  1, 2 to v1 Vector2\n\t * v1.multiply({x:1, y:2});\n\t * // v1 values are now x:2 & y:6\n\t * @example\n\t * const v1 = new Vector2(2, 3);\n\t * const v2 = new Vector2(4, 1);\n\t * // Multiply v2 to v1 Vector2\n\t * v1.multiply(v2);\n\t * // v1 values are now x:8 & y:3, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tmultiply(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.multiplyX(pos.x);\n\t\tthis.multiplyY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Multiply x value of the Vector2 by v\n\t * @param {Number} v The multiplicator\n\t * @returns {Vector2}\n\t */\n\tmultiplyX(v) {\n\t\tthis.x *= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Multiply y value of the Vector2 by v\n\t * @param {Number} v The multiplicator\n\t * @returns {Vector2}\n\t */\n\tmultiplyY(v) {\n\t\tthis.y *= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Dividing values to the the Vector2\n\t * @param {Vector2|Number} p1 Vector2: copy, Number: assign\n\t * @param {Number} p2 Number: assign\n\t * @example\n\t * const v1 = new Vector2(12, 9);\n\t * // Dividing v1 Vector2 by 3\n\t * v1.divide(3);\n\t * // v1 values are now x:4 & y:3\n\t * @example\n\t * const v1 = new Vector2(10, 15);\n\t * // Dividing v1 Vector2 by 2, 5\n\t * v1.divide(2, 5);\n\t * // v1 values are now x:5 & y:3\n\t * @example\n\t * const v1 = new Vector2(5, 8);\n\t * // Dividing v1 Vector2 by 2, 4\n\t * v1.divide({x:2, y:4});\n\t * // v1 values are now x:2.5 & y:2\n\t * @example\n\t * const v1 = new Vector2(12, 10);\n\t * const v2 = new Vector2(6, 2);\n\t * // Dividing v1 Vector2 by 6, 2\n\t * v1.divide(v2);\n\t * // v1 values are now x:2 & y:5, v2 is unchanged\n\t * @returns {Vector2}\n\t */\n\tdivide(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\tthis.divideX(pos.x);\n\t\tthis.divideY(pos.y);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Divinding x value of the Vector2 by v\n\t * @param {Number} v The divisor\n\t * @returns {Vector2}\n\t */\n\tdivideX(v) {\n\t\tthis.x /= v;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Divinding x value of the Vector2 by v\n\t * @param {Number} v The divisor\n\t * @returns {Vector2}\n\t */\n\tdivideY(v) {\n\t\tthis.y /= v;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Inverting the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invert();\n\t * // v1 values are now x:-3 & y:-6\n\t * @returns {Vector2}\n\t */\n\tinvert() {\n\t\tthis.invertX();\n\t\tthis.invertY();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inverting the x value of the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invertX();\n\t * // v1 values are now x:-3 & y:6\n\t * @returns {Vector2}\n\t */\n\tinvertX() {\n\t\tthis.x = 0 - this.x;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inverting the y value of the Vector2\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.invertY();\n\t * // v1 values are now x:3 & y:-6\n\t * @returns {Vector2}\n\t */\n\tinvertY() {\n\t\tthis.y = 0 - this.y;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Rotate the Vector2 arround zero by angle\n\t * @param {Number} angle degrees angle\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * v1.rotate(180);\n\t * // v1 values are now x:-3 & y:-6\n\t * @returns {Vector2}\n\t */\n\trotate(angle) {\n\t\tangle = angle * (Math.PI / 180);\n\t\tconst cos = Math.cos(angle);\n\t\tconst sin = Math.sin(angle);\n\t\tconst x = this.x * 1;\n\t\tconst y = this.y * 1;\n\t\tthis.x = ((x * cos) - (y * sin));\n\t\tthis.y = ((x * sin) + (y * cos));\n\t\tthis.approximate();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Test if the Vector2 is equal to an other\n\t * @param {Vector2|Number} [p1] Vector2: copy, Number: assign\n\t * @param {Number} [p2] Number: assign\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equals(v2); // false\n\t * @returns {Boolean}\n\t */\n\tequals(...args) {\n\t\tconst pos = this._checkParams(args);\n\t\treturn this.equalsX(pos.x) && this.equalsY(pos.y);\n\t}\n\n\t/**\n\t * Test if the x value of the Vector2 is equal to an other\n\t * @param {Number} v The value to compare\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equalsX(v2); // false\n\t * @returns {Boolean}\n\t */\n\tequalsX(v) {\n\t\treturn this.x === v;\n\t}\n\n\t/**\n\t * Test if the y value of the Vector2 is equal to an other\n\t * @param {Number} v The value to compare\n\t * @example\n\t * const v1 = new Vector2(3, 6);\n\t * const v2 = new Vector2(4, 6);\n\t * return v1.equalsY(v2); // true\n\t * @returns {Boolean}\n\t */\n\tequalsY(v) {\n\t\treturn this.y === v;\n\t}\n\n\t/**\n\t * Test if the current Vector2 is inside a polygon\n\t * @param {Polygon} polygon The polygon to check\n\t * @example\n\t * const polygon = new Polygon([\n\t * \tnew Vector2(0,0),\n\t * \tnew Vector2(10,0),\n\t * \tnew Vector2(10,10),\n\t * \tnew Vector2(0,10)\n\t * ]);\n\t * const v1 = new Vector2(5, 5);\n\t * return v1.isInside(polygon); // true\n\t * @returns {Boolean}\n\t */\n\tisInside(polygon) {\n\t\treturn polygon.pointIsInside(this);\n\t}\n\n\t/**\n\t * @see {@link approximated}\n\t * @example\n\t * const v1 = new Vector2(Math.PI, Math.PI);\n\t * console.log(v1.toString()); // {x: 3.141592653589793, y: 3.141592653589793}\n\t * console.log(v1.approximate().toString()); // {x: 3.1416, y: 3.1416}\n\t */\n\tapproximate() {\n\t\tthis.setX(Math.round(this.x * 10000) / 10000).setY(Math.round(this.y * 10000) / 10000);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Approximated value of the Vector2 (used to remove duplicates)\n\t * @see {@link approximate}\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(Math.PI, Math.PI);\n\t * console.log(v1.toString()); // {x: 3.141592653589793, y: 3.141592653589793}\n\t * console.log(v1.approximate.toString()); // {x: 3.1416, y: 3.1416}\n\t */\n\tget approximated() {\n\t\treturn this.clone.approximate();\n\t}\n\n\t/**\n\t * Normalized Vector2\n\t * @see {@link norm}\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(1, 1);\n\t * console.log(v1.normalized.toString()); // {x: 0.7071067811865476, y: 0.7071067811865476}\n\t */\n\tget normalized() {\n\t\treturn this.divide(this.magnitude);\n\t}\n\n\t/**\n\t * Alias of normalized\n\t * @see {@link normalized}\n     * @readonly\n\t * @type {Vector2}\n\t */\n\tget norm() {\n\t\treturn this.normalized;\n\t}\n\n\t/**\n\t * Magnitude of the Vector2\n\t * @type {Number}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(12, 32);\n\t * console.log(v1.magnitude); // 34.17601498127012\n\t */\n\tget magnitude() {\n\t\treturn Math.sqrt((this.x * this.x) + (this.y * this.y));\n\t}\n\n\t/**\n\t * A clone of the Vector2\n\t * @type {Vector2}\n     * @readonly\n\t * @example\n\t * const v1 = new Vector2(5, 5);\n\t * console.log(v1.clone.add(2, 3)); // {x: 7, y: 8}\n\t * // v1 is unchanged\n\t */\n\tget clone() {\n\t\treturn new Vector2(this.x, this.y);\n\t}\n\n\t/**\n\t * Getting JSON string version of the Vector2\n\t * @returns {String}\n\t */\n\ttoString() {\n\t\treturn JSON.stringify({\n\t\t\tx: this.x,\n\t\t\ty: this.y\n\t\t});\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = args[0];\n\t\tconst p2 = args[1];\n\t\tconst pos = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tif (p1 !== null && typeof p1 === 'object') {\n\t\t\tif (typeof p1.x !== 'undefined' && typeof p1.y !== 'undefined') {\n\t\t\t\tpos.x = p1.x * 1;\n\t\t\t\tpos.y = p1.y * 1;\n\t\t\t}\n\t\t} else if (typeof p1 !== 'undefined' && typeof p2 !== 'undefined') {\n\t\t\tpos.x = p1 * 1;\n\t\t\tpos.y = p2 * 1;\n\t\t} else if (typeof p1 !== 'undefined') {\n\t\t\tpos.x = p1 * 1;\n\t\t\tpos.y = p1 * 1;\n\t\t}\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Getting the distance between two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Number}\n\t */\n\tstatic Distance(v1, v2) {\n\t\tconst dx = Math.abs(v1.x - v2.x);\n\t\tconst dy = Math.abs(v1.y - v2.y);\n\t\treturn Math.sqrt((dx * dx) + (dy * dy));\n\t}\n\n\t/**\n\t * Getting the max values from two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Vector2}\n\t */\n\tstatic Max(v1, v2) {\n\t\treturn new Vector2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y));\n\t}\n\n\t/**\n\t * Getting the min values from two Vector2\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @returns {Vector2}\n\t */\n\tstatic Min(v1, v2) {\n\t\treturn new Vector2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y));\n\t}\n\n\t/**\n\t * Getting a Lerp Vector2 from v1 to v2 with t time\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @param {Number} t time of lerp, value should be between 0 and 1\n\t * @returns {Vector2}\n\t */\n\tstatic Lerp(v1, v2, t) {\n\t\tif (t > 1) {\n\t\t\tt = 1;\n\t\t} else if (t < 0) {\n\t\t\tt = 0;\n\t\t}\n\t\treturn Vector2.LerpUnclamped(v1, v2, t);\n\t}\n\n\t/**\n\t * Getting a Lerp Vector2 from v1 to v2 with t time (Unclamped version)\n\t * @param {Vector2} v1 first Vector2\n\t * @param {Vector2} v2 second Vector2\n\t * @param {Number} t time of lerp, value should be between 0 and 1, but it can exceed this values\n\t * @returns {Vector2}\n\t */\n\tstatic LerpUnclamped(v1, v2, t) {\n\t\tconst diffV = v2.clone.substract(v1).multiply(t);\n\t\treturn v1.clone.add(diffV);\n\t}\n\n\t/**\n\t * Test if the passed element is a Vector2 like and return Vector2 corresponding, or false\n\t * @param {any} subject The subject to test\n\t * @returns {Vector2|false} false on failure\n\t */\n\tstatic IsVector2Like(subject) {\n\t\tif (\n\t\t\ttypeof subject === 'object' &&\n\t\t\ttypeof subject.x !== 'undefined' &&\n\t\t\ttypeof subject.y !== 'undefined'\n\t\t) {\n\t\t\tif (subject instanceof Vector2) {\n\t\t\t\treturn subject;\n\t\t\t} else {\n\t\t\t\treturn new Vector2(subject);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n/**\n * A zero Vector2\n * @returns {Vector2}\n */\nVector2.Zero = function() {\n\treturn new Vector2(0, 0);\n};\n\n/**\n * A top Vector2\n * @returns {Vector2}\n */\nVector2.Top = function() {\n\treturn new Vector2(0, -1);\n};\n\n/**\n * A left Vector2\n * @returns {Vector2}\n */\nVector2.Left = function() {\n\treturn new Vector2(-1, 0);\n};\n\n/**\n * A bottom Vector2\n * @returns {Vector2}\n */\nVector2.Bottom = function() {\n\treturn new Vector2(0, 1);\n};\n\n/**\n * A right Vector2\n * @returns {Vector2}\n */\nVector2.Right = function() {\n\treturn new Vector2(1, 0);\n};\n\nmodule.exports = Vector2;\n","'use strict';\n\nconst PolyBool = require('polybooljs');\n\nconst Line = require('./line');\nconst Vector2 = require('./vector2');\n/**\n * Polygon Class\n * @property {Vector2} first The first point of the polygon, follow next on first to iterate\n */\nclass Polygon {\n\t/**\n\t * Create a new Polygon\n\t * @param {Vector2[]} [vertices] Vertices of the polygon\n\t */\n\tconstructor(vertices = []) {\n\t\tthis.children = [];\n\t\tthis.first = null;\n\t\tif (vertices && vertices.length) {\n\t\t\tfor (const vertice of vertices) {\n\t\t\t\tthis.addVertex(vertice);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a polygon\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsidePolygon(point);\n\t}\n\n\t/**\n\t * Checking if point is inside a polygon\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t */\n\tpointIsInsidePolygon(point) {\n\t\tlet oddNodes = false;\n\t\tlet vertex = this.first;\n\t\tlet next = vertex.next;\n\t\tconst x = point.x;\n\t\tconst y = point.y;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t(vertex.y < y && next.y >= y) ||\n\t\t\t\t\t(next.y < y && vertex.y >= y)\n\t\t\t\t) &&\n\t\t\t\t(vertex.x <= x || next.x <= x)\n\t\t\t) {\n\t\t\t\toddNodes ^= (vertex.x + ((y - vertex.y) /\n\t\t\t\t\t(next.y - vertex.y) * (next.x - vertex.x)) < x);\n\t\t\t}\n\t\t\tvertex = vertex.next;\n\t\t\tnext = vertex.next || this.first;\n\t\t} while (!vertex.equals(this.first));\n\t\treturn oddNodes;\n\t}\n\n\t/**\n\t * Setting all children polygons (for holes)\n\t * @param {Polygon[]} polygons Children to set\n\t * @returns {Polygon}\n\t */\n\tsetChildren(polygons) {\n\t\tthis.children = polygons;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adding a child polygon (for hole)\n\t * @param {Polygon} polygon Child polygon to add\n\t * @returns {Polygon}\n\t */\n\taddChild(polygon) {\n\t\tthis.children.push(polygon);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setting vertices of the polygon\n\t * @param {Vector2[]} vertices Vertices to set\n\t * @returns {Polygon}\n\t */\n\tsetVertexes(vertices) {\n\t\tthis.first = null;\n\t\tfor (const v of vertices) {\n\t\t\tthis.addVertex(v);\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Add a new vertices to the end\n\t * @param {Vector2} vertice the vertice to add\n\t * @returns {Polygon}\n\t */\n\taddVertex(vertice) {\n\t\tif (this.first === null) {\n\t\t\tthis.first = vertice;\n\t\t\tthis.first.next = vertice;\n\t\t\tthis.first.prev = vertice;\n\t\t} else {\n\t\t\tconst next = this.first;\n\t\t\tconst prev = next.prev;\n\n\t\t\tnext.prev = vertice;\n\t\t\tvertice.next = next;\n\t\t\tvertice.prev = prev;\n\t\t\tprev.next = vertice;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Is the current polygon colliding with the given polygon\n\t * @param {Polygon} polygon the second polygon for the collision\n\t * @returns {Boolean}\n\t */\n\tcolliding(polygon) {\n\t\treturn Polygon.Colliding(this, polygon);\n\t}\n\n\t/**\n\t * Intersect boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tintersect(polygon) {\n\t\treturn Polygon.Intersect(this, polygon);\n\t}\n\n\t/**\n\t * Difference boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tdifference(p) {\n\t\treturn Polygon.Difference(this, p);\n\t}\n\n\t/**\n\t * Union boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tunion(p) {\n\t\treturn Polygon.Union(this, p);\n\t}\n\n\t/**\n\t * Xor boolean operation on this polygon with the given polygon\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\txor(p) {\n\t\treturn Polygon.Xor(this, p);\n\t}\n\n\n\t/* GETTERS */\n\t/**\n\t * Get region for polybooljs plugin, can be also be used for GeoJson.\n\t * Return a double level array ([[x, y], [x, y], ...])\n\t * @type {Array[]}\n\t * @readonly\n\t */\n\tget region() {\n\t\treturn this.points.map((p) => {\n\t\t\treturn [p.x, p.y];\n\t\t});\n\t}\n\n\t/**\n\t * Get points of the Polygon\n\t * @type {Vector2[]}\n\t * @readonly\n\t */\n\tget points() {\n\t\tconst points = [];\n\t\tlet v = this.first;\n\n\t\tdo {\n\t\t\tpoints.push(v);\n\t\t\tv = v.next;\n\t\t} while (!v.equals(this.first));\n\t\treturn points;\n\t}\n\n\t/**\n\t * Get lines of the Polygon\n\t * @type {Line[]}\n\t * @readonly\n\t */\n\tget lines() {\n\t\tconst lines = [];\n\t\tlet prev = null;\n\t\tlet cur = this.first;\n\t\tdo {\n\t\t\tif (prev !== null) {\n\t\t\t\tlines.push(new Line(prev, cur));\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur.next;\n\t\t} while (!cur.equals(this.first));\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Get area of the Polygon\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget area() {\n\t\tlet total = 0;\n\t\tlet v = this.first;\n\t\tdo {\n\t\t\ttotal += (v.x * v.next.y) - (v.y * v.next.x);\n\t\t\tv = v.next;\n\t\t} while (!v.equals(this.first));\n\n\t\tlet area = total / 2;\n\t\tif (this.children && this.children.length) {\n\t\t\tfor (const child of this.children) {\n\t\t\t\tarea -= child.area;\n\t\t\t}\n\t\t}\n\t\treturn Math.abs(area);\n\t}\n\n\t/**\n\t * Is the p1 polygon colliding with the p2 polygon\n\t * @param {Polygon} p1 the first polygon for the collision\n\t * @param {Polygon} p2 the second polygon for the collision\n\t * @returns {Boolean}\n\t */\n\tstatic Colliding(p1, p2) {\n\t\tconst p1Points = p1.points;\n\t\tconst p2Points = p2.points;\n\t\tfor (const pt1 of p1Points) {\n\t\t\tif (p2.pointIsInside(pt1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (const pt2 of p2Points) {\n\t\t\tif (p1.pointIsInside(pt2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Convert region to polygon\n\t * @param {Array[]} region the region to convert\n\t * @returns {Polygon}\n\t */\n\tstatic FromRegion(region) {\n\t\treturn new Polygon(region.map((p) => {\n\t\t\treturn new Vector2(p[0], p[1]);\n\t\t}));\n\t}\n\n\n\t/**\n\t * Intersect boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Intersect(p1, p2) {\n\t\tconst operation = PolyBool.intersect({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Union boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Union(p1, p2) {\n\t\tconst operation = PolyBool.union({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Difference boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Difference(p1, p2) {\n\t\tconst operation = PolyBool.difference({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n\n\n\t/**\n\t * Xor boolean operation on the p1 polygon with the p2 polygon\n\t * @param {Polygon} polygon the first polygon for the operation\n\t * @param {Polygon} polygon the second polygon for the operation\n\t * @returns {Polygon[]}\n\t */\n\tstatic Xor(p1, p2) {\n\t\tconst operation = PolyBool.xor({\n\t\t\tregions: [\n\t\t\t\tp1.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t}, {\n\t\t\tregions: [\n\t\t\t\tp2.region\n\t\t\t],\n\t\t\tinverted: false\n\t\t});\n\t\treturn operation.regions.map((r) => {\n\t\t\treturn Polygon.FromRegion(r);\n\t\t});\n\t}\n}\n\nmodule.exports = Polygon;\n","'use strict';\n\nconst Vector2 = require('./vector2');\n\n/**\n * Line Class\n * @property {Vector2} start The start position of the line\n * @property {Vector2} end The end position of the line\n */\nclass Line {\n\t/**\n\t * @param {Vector2|Object} [p1] Vector2 like object of the start position\n\t * @param {Vector2|Object} [p2] Vector2 like object of the end position\n\t */\n\tconstructor(...args) {\n\t\tthis.start = new Vector2.Zero();\n\t\tthis.end = new Vector2.Zero();\n\t\tthis._checkParams(args);\n\t}\n\n\t/**\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn Vector2.Distance(this.end, this.start);\n\t}\n\n\t/**\n\t * Get the intersection of this line with an other one\n\t * Return false if lines does not intersect\n\t * @param {Line} line Second line\n\t * @returns boolean|Vector2\n\t */\n\tintersect(line) {\n\t\treturn Line.Intersect(this, line);\n\t}\n\n\t/**\n\t * Get a point on the line from start to end at lerpValue\n\t * @param {Number} lerpValue The lerp value, should be between 0 and 1, and it will be clamped\n\t * @returns Vector2\n\t */\n\talongPoint(lerpValue) {\n\t\treturn Vector2.Lerp(this.start, this.end, lerpValue);\n\t}\n\n\t/**\n\t * Get a point on the line from start to end at lerpValue (Unclamped version)\n\t * @param {Number} lerpValue The lerp value, should be between 0 and 1, but can be out of bound\n\t * @returns Vector2\n\t */\n\talongPointUnclamped(lerpValue) {\n\t\treturn Vector2.LerpUnclamped(this.start, this.end, lerpValue);\n\t}\n\n\t/**\n\t * Get the intersection of two lines\n\t * Return false if lines does not intersect\n\t * @param {Line} l1 First line\n\t * @param {Line} l2 Second line\n\t * @returns boolean|Vector2\n\t */\n\tstatic Intersect(l1, l2) {\n\t\tconst p0x = l1.start.x;\n\t\tconst p0y = l1.start.y;\n\t\tconst p1x = l1.end.x;\n\t\tconst p1y = l1.end.y;\n\t\tconst p2x = l2.start.x;\n\t\tconst p2y = l2.start.y;\n\t\tconst p3x = l2.end.x;\n\t\tconst p3y = l2.end.y;\n\t\tconst s1x = p1x - p0x;\n\t\tconst s1y = p1y - p0y;\n\t\tconst s2x = p3x - p2x;\n\t\tconst s2y = p3y - p2y;\n\n\t\tconst s = ((-s1y * (p0x - p2x)) + (s1x * (p0y - p2y))) / ((-s2x * s1y) + (s1x * s2y));\n\t\tconst t = ((s2x * (p0y - p2y)) - (s2y * (p0x - p2x))) / ((-s2x * s1y) + (s1x * s2y));\n\n\t\tconst p = new Vector2.Zero();\n\t\tif (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n\t\t\tp.x = p0x + (t * s1x);\n\t\t\tp.y = p0y + (t * s1y);\n\t\t\treturn p;\n\t\t}\n\t\treturn false;\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = Vector2.IsVector2Like(args[0]);\n\t\tconst p2 = Vector2.IsVector2Like(args[1]);\n\t\tif (p1 && p2) {\n\t\t\tthis.start = p1;\n\t\t\tthis.end = p2;\n\t\t} else if (p1) {\n\t\t\tthis.end = p1;\n\t\t}\n\t}\n}\n\nmodule.exports = Line;\n","'use strict';\r\n\r\nconst Vector2 = require('./src/vector2');\r\nconst Line = require('./src/line');\r\nconst Polygon = require('./src/polygon');\r\nconst Rect = require('./src/rect');\r\nconst Circle = require('./src/circle');\r\n\r\nmodule.exports = {\r\n\tVector2,\r\n\tLine,\r\n\tPolygon,\r\n\tRect,\r\n\tCircle\r\n};\r\n","/*\n * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc\n * @license MIT\n * @preserve Project Home: https://github.com/voidqk/polybooljs\n */\n\nvar BuildLog = require('./lib/build-log');\nvar Epsilon = require('./lib/epsilon');\nvar Intersecter = require('./lib/intersecter');\nvar SegmentChainer = require('./lib/segment-chainer');\nvar SegmentSelector = require('./lib/segment-selector');\nvar GeoJSON = require('./lib/geojson');\n\nvar buildLog = false;\nvar epsilon = Epsilon();\n\nvar PolyBool;\nPolyBool = {\n\t// getter/setter for buildLog\n\tbuildLog: function(bl){\n\t\tif (bl === true)\n\t\t\tbuildLog = BuildLog();\n\t\telse if (bl === false)\n\t\t\tbuildLog = false;\n\t\treturn buildLog === false ? false : buildLog.list;\n\t},\n\t// getter/setter for epsilon\n\tepsilon: function(v){\n\t\treturn epsilon.epsilon(v);\n\t},\n\n\t// core API\n\tsegments: function(poly){\n\t\tvar i = Intersecter(true, epsilon, buildLog);\n\t\tpoly.regions.forEach(i.addRegion);\n\t\treturn {\n\t\t\tsegments: i.calculate(poly.inverted),\n\t\t\tinverted: poly.inverted\n\t\t};\n\t},\n\tcombine: function(segments1, segments2){\n\t\tvar i3 = Intersecter(false, epsilon, buildLog);\n\t\treturn {\n\t\t\tcombined: i3.calculate(\n\t\t\t\tsegments1.segments, segments1.inverted,\n\t\t\t\tsegments2.segments, segments2.inverted\n\t\t\t),\n\t\t\tinverted1: segments1.inverted,\n\t\t\tinverted2: segments2.inverted\n\t\t};\n\t},\n\tselectUnion: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.union(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 || combined.inverted2\n\t\t}\n\t},\n\tselectIntersect: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.intersect(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectDifference: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.difference(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && !combined.inverted2\n\t\t}\n\t},\n\tselectDifferenceRev: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.differenceRev(combined.combined, buildLog),\n\t\t\tinverted: !combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectXor: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.xor(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 !== combined.inverted2\n\t\t}\n\t},\n\tpolygon: function(segments){\n\t\treturn {\n\t\t\tregions: SegmentChainer(segments.segments, epsilon, buildLog),\n\t\t\tinverted: segments.inverted\n\t\t};\n\t},\n\n\t// GeoJSON converters\n\tpolygonFromGeoJSON: function(geojson){\n\t\treturn GeoJSON.toPolygon(PolyBool, geojson);\n\t},\n\tpolygonToGeoJSON: function(poly){\n\t\treturn GeoJSON.fromPolygon(PolyBool, epsilon, poly);\n\t},\n\n\t// helper functions for common operations\n\tunion: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectUnion);\n\t},\n\tintersect: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectIntersect);\n\t},\n\tdifference: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifference);\n\t},\n\tdifferenceRev: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifferenceRev);\n\t},\n\txor: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectXor);\n\t}\n};\n\nfunction operate(poly1, poly2, selector){\n\tvar seg1 = PolyBool.segments(poly1);\n\tvar seg2 = PolyBool.segments(poly2);\n\tvar comb = PolyBool.combine(seg1, seg2);\n\tvar seg3 = selector(comb);\n\treturn PolyBool.polygon(seg3);\n}\n\nif (typeof window === 'object')\n\twindow.PolyBool = PolyBool;\n\nmodule.exports = PolyBool;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// used strictly for logging the processing of the algorithm... only useful if you intend on\n// looking under the covers (for pretty UI's or debugging)\n//\n\nfunction BuildLog(){\n\tvar my;\n\tvar nextSegmentId = 0;\n\tvar curVert = false;\n\n\tfunction push(type, data){\n\t\tmy.list.push({\n\t\t\ttype: type,\n\t\t\tdata: data ? JSON.parse(JSON.stringify(data)) : void 0\n\t\t});\n\t\treturn my;\n\t}\n\n\tmy = {\n\t\tlist: [],\n\t\tsegmentId: function(){\n\t\t\treturn nextSegmentId++;\n\t\t},\n\t\tcheckIntersection: function(seg1, seg2){\n\t\t\treturn push('check', { seg1: seg1, seg2: seg2 });\n\t\t},\n\t\tsegmentChop: function(seg, end){\n\t\t\tpush('div_seg', { seg: seg, pt: end });\n\t\t\treturn push('chop', { seg: seg, pt: end });\n\t\t},\n\t\tstatusRemove: function(seg){\n\t\t\treturn push('pop_seg', { seg: seg });\n\t\t},\n\t\tsegmentUpdate: function(seg){\n\t\t\treturn push('seg_update', { seg: seg });\n\t\t},\n\t\tsegmentNew: function(seg, primary){\n\t\t\treturn push('new_seg', { seg: seg, primary: primary });\n\t\t},\n\t\tsegmentRemove: function(seg){\n\t\t\treturn push('rem_seg', { seg: seg });\n\t\t},\n\t\ttempStatus: function(seg, above, below){\n\t\t\treturn push('temp_status', { seg: seg, above: above, below: below });\n\t\t},\n\t\trewind: function(seg){\n\t\t\treturn push('rewind', { seg: seg });\n\t\t},\n\t\tstatus: function(seg, above, below){\n\t\t\treturn push('status', { seg: seg, above: above, below: below });\n\t\t},\n\t\tvert: function(x){\n\t\t\tif (x === curVert)\n\t\t\t\treturn my;\n\t\t\tcurVert = x;\n\t\t\treturn push('vert', { x: x });\n\t\t},\n\t\tlog: function(data){\n\t\t\tif (typeof data !== 'string')\n\t\t\t\tdata = JSON.stringify(data, false, '  ');\n\t\t\treturn push('log', { txt: data });\n\t\t},\n\t\treset: function(){\n\t\t\treturn push('reset');\n\t\t},\n\t\tselected: function(segs){\n\t\t\treturn push('selected', { segs: segs });\n\t\t},\n\t\tchainStart: function(seg){\n\t\t\treturn push('chain_start', { seg: seg });\n\t\t},\n\t\tchainRemoveHead: function(index, pt){\n\t\t\treturn push('chain_rem_head', { index: index, pt: pt });\n\t\t},\n\t\tchainRemoveTail: function(index, pt){\n\t\t\treturn push('chain_rem_tail', { index: index, pt: pt });\n\t\t},\n\t\tchainNew: function(pt1, pt2){\n\t\t\treturn push('chain_new', { pt1: pt1, pt2: pt2 });\n\t\t},\n\t\tchainMatch: function(index){\n\t\t\treturn push('chain_match', { index: index });\n\t\t},\n\t\tchainClose: function(index){\n\t\t\treturn push('chain_close', { index: index });\n\t\t},\n\t\tchainAddHead: function(index, pt){\n\t\t\treturn push('chain_add_head', { index: index, pt: pt });\n\t\t},\n\t\tchainAddTail: function(index, pt){\n\t\t\treturn push('chain_add_tail', { index: index, pt: pt, });\n\t\t},\n\t\tchainConnect: function(index1, index2){\n\t\t\treturn push('chain_con', { index1: index1, index2: index2 });\n\t\t},\n\t\tchainReverse: function(index){\n\t\t\treturn push('chain_rev', { index: index });\n\t\t},\n\t\tchainJoin: function(index1, index2){\n\t\t\treturn push('chain_join', { index1: index1, index2: index2 });\n\t\t},\n\t\tdone: function(){\n\t\t\treturn push('done');\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = BuildLog;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\n\nfunction Epsilon(eps){\n\tif (typeof eps !== 'number')\n\t\teps = 0.0000000001; // sane default? sure why not\n\tvar my = {\n\t\tepsilon: function(v){\n\t\t\tif (typeof v === 'number')\n\t\t\t\teps = v;\n\t\t\treturn eps;\n\t\t},\n\t\tpointAboveOrOnLine: function(pt, left, right){\n\t\t\tvar Ax = left[0];\n\t\t\tvar Ay = left[1];\n\t\t\tvar Bx = right[0];\n\t\t\tvar By = right[1];\n\t\t\tvar Cx = pt[0];\n\t\t\tvar Cy = pt[1];\n\t\t\treturn (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n\t\t},\n\t\tpointBetween: function(p, left, right){\n\t\t\t// p must be collinear with left->right\n\t\t\t// returns false if p == left, p == right, or left == right\n\t\t\tvar d_py_ly = p[1] - left[1];\n\t\t\tvar d_rx_lx = right[0] - left[0];\n\t\t\tvar d_px_lx = p[0] - left[0];\n\t\t\tvar d_ry_ly = right[1] - left[1];\n\n\t\t\tvar dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;\n\t\t\t// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n\t\t\t// if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\t\t\tif (dot < eps)\n\t\t\t\treturn false;\n\n\t\t\tvar sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;\n\t\t\t// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n\t\t\t// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\t\t\tif (dot - sqlen > -eps)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t},\n\t\tpointsSameX: function(p1, p2){\n\t\t\treturn Math.abs(p1[0] - p2[0]) < eps;\n\t\t},\n\t\tpointsSameY: function(p1, p2){\n\t\t\treturn Math.abs(p1[1] - p2[1]) < eps;\n\t\t},\n\t\tpointsSame: function(p1, p2){\n\t\t\treturn my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n\t\t},\n\t\tpointsCompare: function(p1, p2){\n\t\t\t// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n\t\t\tif (my.pointsSameX(p1, p2))\n\t\t\t\treturn my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);\n\t\t\treturn p1[0] < p2[0] ? -1 : 1;\n\t\t},\n\t\tpointsCollinear: function(pt1, pt2, pt3){\n\t\t\t// does pt1->pt2->pt3 make a straight line?\n\t\t\t// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n\t\t\t// if slopes are equal, then they must be collinear, because they share pt2\n\t\t\tvar dx1 = pt1[0] - pt2[0];\n\t\t\tvar dy1 = pt1[1] - pt2[1];\n\t\t\tvar dx2 = pt2[0] - pt3[0];\n\t\t\tvar dy2 = pt2[1] - pt3[1];\n\t\t\treturn Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n\t\t},\n\t\tlinesIntersect: function(a0, a1, b0, b1){\n\t\t\t// returns false if the lines are coincident (e.g., parallel or on top of each other)\n\t\t\t//\n\t\t\t// returns an object if the lines intersect:\n\t\t\t//   {\n\t\t\t//     pt: [x, y],    where the intersection point is at\n\t\t\t//     alongA: where intersection point is along A,\n\t\t\t//     alongB: where intersection point is along B\n\t\t\t//   }\n\t\t\t//\n\t\t\t//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n\t\t\t//\n\t\t\t//  with the following meaning:\n\t\t\t//\n\t\t\t//    -2   intersection point is before segment's first point\n\t\t\t//    -1   intersection point is directly on segment's first point\n\t\t\t//     0   intersection point is between segment's first and second points (exclusive)\n\t\t\t//     1   intersection point is directly on segment's second point\n\t\t\t//     2   intersection point is after segment's second point\n\t\t\tvar adx = a1[0] - a0[0];\n\t\t\tvar ady = a1[1] - a0[1];\n\t\t\tvar bdx = b1[0] - b0[0];\n\t\t\tvar bdy = b1[1] - b0[1];\n\n\t\t\tvar axb = adx * bdy - ady * bdx;\n\t\t\tif (Math.abs(axb) < eps)\n\t\t\t\treturn false; // lines are coincident\n\n\t\t\tvar dx = a0[0] - b0[0];\n\t\t\tvar dy = a0[1] - b0[1];\n\n\t\t\tvar A = (bdx * dy - bdy * dx) / axb;\n\t\t\tvar B = (adx * dy - ady * dx) / axb;\n\n\t\t\tvar ret = {\n\t\t\t\talongA: 0,\n\t\t\t\talongB: 0,\n\t\t\t\tpt: [\n\t\t\t\t\ta0[0] + A * adx,\n\t\t\t\t\ta0[1] + A * ady\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// categorize where intersection point is along A and B\n\n\t\t\tif (A <= -eps)\n\t\t\t\tret.alongA = -2;\n\t\t\telse if (A < eps)\n\t\t\t\tret.alongA = -1;\n\t\t\telse if (A - 1 <= -eps)\n\t\t\t\tret.alongA = 0;\n\t\t\telse if (A - 1 < eps)\n\t\t\t\tret.alongA = 1;\n\t\t\telse\n\t\t\t\tret.alongA = 2;\n\n\t\t\tif (B <= -eps)\n\t\t\t\tret.alongB = -2;\n\t\t\telse if (B < eps)\n\t\t\t\tret.alongB = -1;\n\t\t\telse if (B - 1 <= -eps)\n\t\t\t\tret.alongB = 0;\n\t\t\telse if (B - 1 < eps)\n\t\t\t\tret.alongB = 1;\n\t\t\telse\n\t\t\t\tret.alongB = 2;\n\n\t\t\treturn ret;\n\t\t},\n\t\tpointInsideRegion: function(pt, region){\n\t\t\tvar x = pt[0];\n\t\t\tvar y = pt[1];\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar inside = false;\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\n\t\t\t\t// if y is between curr_y and last_y, and\n\t\t\t\t// x is to the right of the boundary created by the line\n\t\t\t\tif ((curr_y - y > eps) != (last_y - y > eps) &&\n\t\t\t\t\t(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)\n\t\t\t\t\tinside = !inside\n\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\treturn inside;\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = Epsilon;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// simple linked list implementation that allows you to traverse down nodes and save positions\n//\n\nvar LinkedList = {\n\tcreate: function(){\n\t\tvar my = {\n\t\t\troot: { root: true, next: null },\n\t\t\texists: function(node){\n\t\t\t\tif (node === null || node === my.root)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tisEmpty: function(){\n\t\t\t\treturn my.root.next === null;\n\t\t\t},\n\t\t\tgetHead: function(){\n\t\t\t\treturn my.root.next;\n\t\t\t},\n\t\t\tinsertBefore: function(node, check){\n\t\t\t\tvar last = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here)){\n\t\t\t\t\t\tnode.prev = here.prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\there.prev.next = node;\n\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlast = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\tlast.next = node;\n\t\t\t\tnode.prev = last;\n\t\t\t\tnode.next = null;\n\t\t\t},\n\t\t\tfindTransition: function(check){\n\t\t\t\tvar prev = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbefore: prev === my.root ? null : prev,\n\t\t\t\t\tafter: here,\n\t\t\t\t\tinsert: function(node){\n\t\t\t\t\t\tnode.prev = prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\tprev.next = node;\n\t\t\t\t\t\tif (here !== null)\n\t\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn my;\n\t},\n\tnode: function(data){\n\t\tdata.prev = null;\n\t\tdata.next = null;\n\t\tdata.remove = function(){\n\t\t\tdata.prev.next = data.next;\n\t\t\tif (data.next)\n\t\t\t\tdata.next.prev = data.prev;\n\t\t\tdata.prev = null;\n\t\t\tdata.next = null;\n\t\t};\n\t\treturn data;\n\t}\n};\n\nmodule.exports = LinkedList;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\n\nfunction SegmentChainer(segments, eps, buildLog){\n\tvar chains = [];\n\tvar regions = [];\n\n\tsegments.forEach(function(seg){\n\t\tvar pt1 = seg.start;\n\t\tvar pt2 = seg.end;\n\t\tif (eps.pointsSame(pt1, pt2)){\n\t\t\tconsole.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t'probably too small or too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainStart(seg);\n\n\t\t// search for two chains that this segment matches\n\t\tvar first_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar second_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar next_match = first_match;\n\t\tfunction setMatch(index, matches_head, matches_pt1){\n\t\t\t// return true if we've matched twice\n\t\t\tnext_match.index = index;\n\t\t\tnext_match.matches_head = matches_head;\n\t\t\tnext_match.matches_pt1 = matches_pt1;\n\t\t\tif (next_match === first_match){\n\t\t\t\tnext_match = second_match;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnext_match = null;\n\t\t\treturn true; // we've matched twice, we're done here\n\t\t}\n\t\tfor (var i = 0; i < chains.length; i++){\n\t\t\tvar chain = chains[i];\n\t\t\tvar head  = chain[0];\n\t\t\tvar head2 = chain[1];\n\t\t\tvar tail  = chain[chain.length - 1];\n\t\t\tvar tail2 = chain[chain.length - 2];\n\t\t\tif (eps.pointsSame(head, pt1)){\n\t\t\t\tif (setMatch(i, true, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(head, pt2)){\n\t\t\t\tif (setMatch(i, true, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt1)){\n\t\t\t\tif (setMatch(i, false, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt2)){\n\t\t\t\tif (setMatch(i, false, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (next_match === first_match){\n\t\t\t// we didn't match anything, so create a new chain\n\t\t\tchains.push([ pt1, pt2 ]);\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainNew(pt1, pt2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next_match === second_match){\n\t\t\t// we matched a single chain\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainMatch(first_match.index);\n\n\t\t\t// add the other point to the apporpriate end, and check to see if we've closed the\n\t\t\t// chain into a loop\n\n\t\t\tvar index = first_match.index;\n\t\t\tvar pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\t\t\tvar addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n\t\t\tvar chain = chains[index];\n\t\t\tvar grow  = addToHead ? chain[0] : chain[chain.length - 1];\n\t\t\tvar grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n\t\t\tvar oppo  = addToHead ? chain[chain.length - 1] : chain[0];\n\t\t\tvar oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n\t\t\tif (eps.pointsCollinear(grow2, grow, pt)){\n\t\t\t\t// grow isn't needed because it's directly between grow2 and pt:\n\t\t\t\t// grow2 ---grow---> pt\n\t\t\t\tif (addToHead){\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, pt);\n\t\t\t\t\tchain.shift();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, pt);\n\t\t\t\t\tchain.pop();\n\t\t\t\t}\n\t\t\t\tgrow = grow2; // old grow is gone... new grow is what grow2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsSame(oppo, pt)){\n\t\t\t\t// we're closing the loop, so remove chain from chains\n\t\t\t\tchains.splice(index, 1);\n\n\t\t\t\tif (eps.pointsCollinear(oppo2, oppo, grow)){\n\t\t\t\t\t// oppo isn't needed because it's directly between oppo2 and grow:\n\t\t\t\t\t// oppo2 ---oppo--->grow\n\t\t\t\t\tif (addToHead){\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, grow);\n\t\t\t\t\t\tchain.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, grow);\n\t\t\t\t\t\tchain.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainClose(first_match.index);\n\n\t\t\t\t// we have a closed chain!\n\t\t\t\tregions.push(chain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// not closing a loop, so just add it to the apporpriate side\n\t\t\tif (addToHead){\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddHead(first_match.index, pt);\n\t\t\t\tchain.unshift(pt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddTail(first_match.index, pt);\n\t\t\t\tchain.push(pt);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise, we matched two chains, so we need to combine those chains together\n\n\t\tfunction reverseChain(index){\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainReverse(index);\n\t\t\tchains[index].reverse(); // gee, that's easy\n\t\t}\n\n\t\tfunction appendChain(index1, index2){\n\t\t\t// index1 gets index2 appended to it, and index2 is removed\n\t\t\tvar chain1 = chains[index1];\n\t\t\tvar chain2 = chains[index2];\n\t\t\tvar tail  = chain1[chain1.length - 1];\n\t\t\tvar tail2 = chain1[chain1.length - 2];\n\t\t\tvar head  = chain2[0];\n\t\t\tvar head2 = chain2[1];\n\n\t\t\tif (eps.pointsCollinear(tail2, tail, head)){\n\t\t\t\t// tail isn't needed because it's directly between tail2 and head\n\t\t\t\t// tail2 ---tail---> head\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveTail(index1, tail);\n\t\t\t\tchain1.pop();\n\t\t\t\ttail = tail2; // old tail is gone... new tail is what tail2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsCollinear(tail, head, head2)){\n\t\t\t\t// head isn't needed because it's directly between tail and head2\n\t\t\t\t// tail ---head---> head2\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveHead(index2, head);\n\t\t\t\tchain2.shift();\n\t\t\t}\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainJoin(index1, index2);\n\t\t\tchains[index1] = chain1.concat(chain2);\n\t\t\tchains.splice(index2, 1);\n\t\t}\n\n\t\tvar F = first_match.index;\n\t\tvar S = second_match.index;\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainConnect(F, S);\n\n\t\tvar reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\t\tif (first_match.matches_head){\n\t\t\tif (second_match.matches_head){\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\tappendChain(S, F);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (second_match.matches_head){\n\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\tappendChain(F, S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn regions;\n}\n\nmodule.exports = SegmentChainer;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// filter a list of segments based on boolean operations\n//\n\nfunction select(segments, selection, buildLog){\n\tvar result = [];\n\tsegments.forEach(function(seg){\n\t\tvar index =\n\t\t\t(seg.myFill.above ? 8 : 0) +\n\t\t\t(seg.myFill.below ? 4 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.above) ? 2 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.below) ? 1 : 0);\n\t\tif (selection[index] !== 0){\n\t\t\t// copy the segment to the results, while also calculating the fill status\n\t\t\tresult.push({\n\t\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\t\tstart: seg.start,\n\t\t\t\tend: seg.end,\n\t\t\t\tmyFill: {\n\t\t\t\t\tabove: selection[index] === 1, // 1 if filled above\n\t\t\t\t\tbelow: selection[index] === 2  // 2 if filled below\n\t\t\t\t},\n\t\t\t\totherFill: null\n\t\t\t});\n\t\t}\n\t});\n\n\tif (buildLog)\n\t\tbuildLog.selected(result);\n\n\treturn result;\n}\n\nvar SegmentSelector = {\n\tunion: function(segments, buildLog){ // primary | secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 2, 0, 0,\n\t\t\t1, 0, 1, 0,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\tintersect: function(segments, buildLog){ // primary & secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled below    2\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   yes filled above    1\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled below    2\n\t\t//    1      1      1      0   =>   yes filled above    1\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 1, 0\n\t\t], buildLog);\n\t},\n\tdifference: function(segments, buildLog){ // primary - secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled below    2\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   yes filled above    1\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t2, 0, 2, 0,\n\t\t\t1, 1, 0, 0,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t},\n\tdifferenceRev: function(segments, buildLog){ // secondary - primary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled above    1\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   yes filled below    2\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\txor: function(segments, buildLog){ // primary ^ secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 0, 0, 1,\n\t\t\t1, 0, 0, 2,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t}\n};\n\nmodule.exports = SegmentSelector;\n","// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n\t// convert a GeoJSON object to a PolyBool polygon\n\ttoPolygon: function(PolyBool, geojson){\n\n\t\t// converts list of LineString's to segments\n\t\tfunction GeoPoly(coords){\n\t\t\t// check for empty coords\n\t\t\tif (coords.length <= 0)\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\n\n\t\t\t// convert LineString to segments\n\t\t\tfunction LineString(ls){\n\t\t\t\t// remove tail which should be the same as head\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\n\t\t\t}\n\n\t\t\t// the first LineString is considered the outside\n\t\t\tvar out = LineString(coords[0]);\n\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\n\t\t\t// current result\n\t\t\tfor (var i = 1; i < coords.length; i++)\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n\t\t\treturn out;\n\t\t}\n\n\t\tif (geojson.type === 'Polygon'){\n\t\t\t// single polygon, so just convert it and we're done\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\n\t\t}\n\t\telse if (geojson.type === 'MultiPolygon'){\n\t\t\t// multiple polygons, so union all the polygons together\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\t\t\treturn PolyBool.polygon(out);\n\t\t}\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n\t},\n\n\t// convert a PolyBool polygon to a GeoJSON object\n\tfromPolygon: function(PolyBool, eps, poly){\n\t\t// make sure out polygon is clean\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\n\n\t\t// test if r1 is inside r2\n\t\tfunction regionInsideRegion(r1, r2){\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n\t\t\t// edge of the first line, which cannot be on an edge\n\t\t\treturn eps.pointInsideRegion([\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\n\t\t\t], r2);\n\t\t}\n\n\t\t// calculate inside heirarchy\n\t\t//\n\t\t//  _____________________   _______    roots -> A       -> F\n\t\t// |          A          | |   F   |            |          |\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\n\t\t// | |   B   | |   C   | | | |   | |            |   |\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\n\t\t// | | | D | | | | E | | | | | G | |            |\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\n\t\t// | |_______| |_______| | | |___| |                |\n\t\t// |_____________________| |_______|                +-- E\n\n\t\tfunction newNode(region){\n\t\t\treturn {\n\t\t\t\tregion: region,\n\t\t\t\tchildren: []\n\t\t\t};\n\t\t}\n\n\t\tvar roots = newNode(null);\n\n\t\tfunction addChild(root, region){\n\t\t\t// first check if we're inside any children\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(region, child.region)){\n\t\t\t\t\t// we are, so insert inside them instead\n\t\t\t\t\taddChild(child, region);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not inside any children, so check to see if any children are inside us\n\t\t\tvar node = newNode(region);\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(child.region, region)){\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\n\t\t\t\t\tnode.children.push(child);\n\t\t\t\t\troot.children.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we can add ourselves\n\t\t\troot.children.push(node);\n\t\t}\n\n\t\t// add all regions to the root\n\t\tfor (var i = 0; i < poly.regions.length; i++){\n\t\t\tvar region = poly.regions[i];\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\n\t\t\t\tcontinue;\n\t\t\taddChild(roots, region);\n\t\t}\n\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\n\t\t// children's children's children are interior, etc\n\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\t\tfunction forceWinding(region, clockwise){\n\t\t\t// first, see if we're clockwise or counter-clockwise\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\n\t\t\tvar winding = 0;\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar copy = [];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\n\t\t\tvar isclockwise = winding < 0;\n\t\t\tif (isclockwise !== clockwise)\n\t\t\t\tcopy.reverse();\n\t\t\t// while we're here, the last point must be the first point...\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\n\t\t\treturn copy;\n\t\t}\n\n\t\tvar geopolys = [];\n\n\t\tfunction addExterior(node){\n\t\t\tvar poly = [forceWinding(node.region, false)];\n\t\t\tgeopolys.push(poly);\n\t\t\t// children of exteriors are interior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\tpoly.push(getInterior(node.children[i]));\n\t\t}\n\n\t\tfunction getInterior(node){\n\t\t\t// children of interiors are exterior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\taddExterior(node.children[i]);\n\t\t\t// return the clockwise interior\n\t\t\treturn forceWinding(node.region, true);\n\t\t}\n\n\t\t// root nodes are exterior\n\t\tfor (var i = 0; i < roots.children.length; i++)\n\t\t\taddExterior(roots.children[i]);\n\n\t\t// lastly, construct the approrpriate GeoJSON object\n\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: [] };\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\n\t\t\ttype: 'MultiPolygon',\n\t\t\tcoordinates: geopolys\n\t\t};\n\t}\n};\n\nmodule.exports = GeoJSON;\n","'use strict';\n\nconst Vector2 = require('./vector2');\nconst Polygon = require('./polygon');\n/**\n * Rect Class\n * @extends Polygon\n * @property {Vector2} position\n * @property {Vector2} size\n */\nclass Rect extends Polygon {\n\t/**\n\t * @param {Vector2|Object|Number} [p1] Vector2 like object of the start position | position.x\n\t * @param {Vector2|Object|Number} [p2] Vector2 like object of the size | position.y\n\t * @param {Number} [p3] size.x\n\t * @param {Number} [p4] size.y\n\t */\n\tconstructor(...args) {\n\t\tsuper();\n\t\tthis._position = Vector2.zero;\n\t\tthis._size = Vector2.zero;\n\t\tthis._checkParams(args);\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a rect\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t * @override\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsideRect(point);\n\t}\n\n\t/**\n     * Check if a point is inside a Rect\n     * @param {Vector2} point The Vector2 like object\n     * @returns {Boolean}\n     */\n\tpointIsInsideRect(point) {\n\t\tconst ps = this._position;\n\t\tconst pe = this._position.clone.add(this._size);\n\t\tconst pmin = new Vector2(\n\t\t\tMath.min(ps.x, pe.x),\n\t\t\tMath.min(ps.y, pe.y)\n\t\t);\n\t\tconst pmax = new Vector2(\n\t\t\tMath.max(ps.x, pe.x),\n\t\t\tMath.max(ps.y, pe.y)\n\t\t);\n\t\tif (\n\t\t\tpoint.x >= pmin.x &&\n\t\t\tpoint.x <= pmax.x &&\n\t\t\tpoint.y >= pmin.y &&\n\t\t\tpoint.y <= pmax.y\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * The start position of the rect\n     * @type {Vector2}\n     */\n\tget position() {\n\t\treturn this._position;\n\t}\n\n\t/**\n\t * The size of the rect\n     * @type {Vector2}\n     */\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\tset position(value) {\n\t\tthis._position = value;\n\t\tthis._calcPoly();\n\t}\n\n\tset size(value) {\n\t\tthis._size = value;\n\t\tthis._calcPoly();\n\t}\n\n\t_checkParams(args) {\n\t\tconst p1 = Vector2.IsVector2Like(args[0]) || args[0];\n\t\tconst p2 = Vector2.IsVector2Like(args[1]) || args[1];\n\t\tconst p3 = args[2];\n\t\tconst p4 = args[3];\n\t\tif (\n\t\t\tp1 && typeof p1 === 'object' &&\n\t\t\tp2 && typeof p2 === 'object'\n\t\t) { // (Vector2 position, Vector2 size)\n\t\t\tthis._position = p1;\n\t\t\tthis._size = p2;\n\t\t} else if (\n\t\t\tp1 && typeof p1 !== 'undefined' && typeof p1 !== 'object' &&\n\t\t\tp2 && typeof p2 !== 'undefined' && typeof p2 !== 'object' &&\n\t\t\tp3 && typeof p3 !== 'undefined' && typeof p3 !== 'object' &&\n\t\t\tp4 && typeof p4 !== 'undefined' && typeof p4 !== 'object'\n\t\t) { // (Vector2 position, Vector2 size)\n\t\t\tthis._position.x = p1;\n\t\t\tthis._position.y = p2;\n\t\t\tthis._size.x = p3;\n\t\t\tthis._size.y = p4;\n\t\t}\n\t\tthis._calcPoly();\n\t}\n\n\t_calcPoly() {\n\t\tthis.setVertexes([\n\t\t\tthis._position,\n\t\t\tthis._position.clone.add(new Vector2(this._size.x, 0)),\n\t\t\tthis._position.clone.add(this._size),\n\t\t\tthis._position.clone.add(new Vector2(0, this._size.y))\n\t\t]);\n\t}\n\n\t/**\n     * Get the box around a polygon or around points\n     * @param {Polygon|Vector2[]} p The polygon, or array of Vector2\n     * @returns {Rect}\n     */\n\tstatic Box(p) {\n\t\tif (p && typeof p === 'object') {\n\t\t\tif (p instanceof Polygon) {\n\t\t\t\tp = p.points;\n\t\t\t}\n\t\t\tif (p instanceof Array && p.length) {\n\t\t\t\tconst xs = p.map(_ => _.x);\n\t\t\t\tconst ys = p.map(_ => _.y);\n\t\t\t\tconst position = new Vector2(Math.min(...xs), Math.min(...ys));\n\t\t\t\tconst size = new Vector2(Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));\n\t\t\t\treturn new Rect(position, size);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\nmodule.exports = Rect;\n","'use strict';\n\nconst Polygon = require('./polygon');\nconst Vector2 = require('./vector2');\n\n/**\n * Circle Class\n * @extends Polygon\n */\nclass Circle extends Polygon {\n\t/**\n     * Create a circle polygon\n     * @param {Vector2} center The center of the circle\n     * @param {Number} radius The radius of the circle\n     * @param {Number} sides Sides count of the polygon circle\n     */\n\tconstructor(center, radius, sides) {\n\t\tsuper();\n\t\tthis._center = center;\n\t\tthis._radius = Math.abs(radius);\n\t\tthis._sides = parseInt(sides);\n\t\tif (this._sides < 3) {\n\t\t\tthis._sides = 3;\n\t\t}\n\t\tif (this._radius <= 0) {\n\t\t\tthis._radius = 1;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\t/**\n\t * Wrapper for checking if point is inside a circle\n\t * @param {Vector2} point Point to check\n\t * @returns {boolean}\n\t * @override\n\t */\n\tpointIsInside(point) {\n\t\treturn this.pointIsInsideCircle(point);\n\t}\n\n\t/**\n     * Check if a point is inside a Circle\n     * @param {Vector2} point The Vector2 like object\n     * @returns {Boolean}\n     */\n\tpointIsInsideCircle(point) {\n\t\treturn (Vector2.Distance(this._center, point) <= this._radius);\n\t}\n\n\t/**\n\t * Sides count of the circle\n\t * @type {Number}\n\t */\n\tget sides() {\n\t\treturn this._sides;\n\t}\n\n\tset sides(value) {\n\t\tthis._sides = parseInt(value);\n\t\tif (this._sides < 3) {\n\t\t\tthis._sides = 3;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\n\t/**\n\t * Center of the circle\n\t * @type {Vector2}\n\t */\n\tget center() {\n\t\treturn this._center;\n\t}\n\n\tset center(value) {\n\t\tthis._center = value;\n\t\tthis._calc();\n\t}\n\n\t/**\n\t * Radius of the circle\n\t * @type {Number}\n\t */\n\tget radius() {\n\t\treturn this._radius;\n\t}\n\n\tset radius(value) {\n\t\tthis._radius = value;\n\t\tif (this._radius <= 0) {\n\t\t\tthis._radius = 1;\n\t\t}\n\t\tthis._calc();\n\t}\n\n\t_calc() {\n\t\tthis.first = null;\n\t\tfor (let i = 0; i < this._sides; i++) {\n\t\t\tthis.addVertex(new Vector2(0, this._radius).rotate(i / this._sides * 360).add(this._center));\n\t\t}\n\t}\n}\n\nmodule.exports = Circle;\n"],"sourceRoot":""}